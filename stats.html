<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>HdR Watch Project Stats</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üìö</text></svg>">
 <script src="https://cdn.jsdelivr.net/npm/chart.js@latest/dist/chart.umd.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      line-height: 1.6;
      color: #dddddd;
      background: #222222;
      min-height: 100vh;
      padding: 20px;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
      background: #222222;
      border-radius: 12px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
      overflow: hidden;
    }

    header {
      background: #111111;
      color: #dddddd;
      padding: 30px 30px;
      text-align: center;
    }

    header h1 {
      font-size: 2em;
      margin-bottom: 8px;
      font-weight: 700;
    }

    header p {
      font-size: 0.95em;
      opacity: 0.95;
    }

    .nav-links {
      margin-bottom: 14px;
      display: flex;
      gap: 10px;
      justify-content: center;
      flex-wrap: wrap;
    }

    .nav-links a {
      display: inline-block;
      padding: 10px 20px;
      background: #0F82AF;
      color: white;
      text-decoration: none;
      border-radius: 6px;
      font-weight: 600;
      font-size: 0.9em;
      transition: opacity 0.2s;
    }

    .nav-links a:hover {
      opacity: 0.8;
    }

    .nav-links a.current {
      background: #666666;
      cursor: default;
    }

    .nav-links a.current:hover {
      opacity: 1;
    }

    .content {
      padding: 30px;
    }

    .chart-selector {
      background: #313131;
      border-radius: 8px;
      padding: 20px;
      border: 1px solid #444444;
      margin-bottom: 20px;
    }

    .chart-selector label {
      display: block;
      color: #099dd7;
      font-weight: 600;
      margin-bottom: 10px;
      font-size: 1em;
    }

    .chart-selector select {
      width: 100%;
      padding: 10px 14px;
      background: #222222;
      color: #dddddd;
      border: 1px solid #555555;
      border-radius: 6px;
      font-size: 0.95em;
      cursor: pointer;
      outline: none;
    }

    .chart-selector select:hover {
      border-color: #0F82AF;
    }

    .chart-selector select:focus {
      border-color: #099dd7;
      box-shadow: 0 0 0 3px rgba(15, 130, 175, 0.1);
    }

    .stats-layout {
      display: grid;
      grid-template-columns: 2fr 1fr;
      gap: 20px;
    }

    @media (max-width: 768px) {
      .stats-layout {
        grid-template-columns: 1fr;
      }
    }

    .stats-card {
      background: #313131;
      border-radius: 8px;
      padding: 20px;
      border: 1px solid #444444;
      color: #dddddd;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .stats-card h2 {
      color: #099dd7;
      margin-bottom: 4px;
      font-size: 1.1em;
    }

    .stats-meta {
      font-size: 0.85em;
      color: #cccccc;
    }

    .chart-container {
      position: relative;
      width: 100%;
      height: 400px;
      margin-top: 4px;
    }

    canvas {
      width: 100% !important;
      height: 100% !important;
    }

    .summary-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
      font-size: 0.85em;
    }

    .summary-row {
      display: flex;
      justify-content: space-between;
      gap: 8px;
    }

    .summary-label {
      color: #dddddd;
      font-weight: 600;
    }

    .summary-value {
      text-align: right;
      white-space: nowrap;
    }

    .badge {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-size: 0.8em;
      padding: 4px 10px;
      border-radius: 999px;
      background: #111111;
      border: 1px solid #444444;
    }

    .badge-dot {
      width: 7px;
      height: 7px;
      border-radius: 999px;
      background: #0F82AF;
    }

    .error-banner {
      display: none;
      margin-top: 8px;
      font-size: 0.8em;
      padding: 8px 10px;
      border-radius: 6px;
      background: rgba(239, 68, 68, 0.15);
      border: 1px solid rgba(248, 113, 113, 0.6);
      color: #fecaca;
    }

    .error-banner.visible {
      display: block;
    }

    .chart-section {
      display: none;
    }

    .chart-section.active {
      display: block;
    }

    footer {
      text-align: center;
      padding: 20px 30px 26px;
      background: #111111;
      color: #dddddd;
      font-size: 0.85em;
    }

    footer a {
      color: #099dd7;
      text-decoration: none;
    }

    footer a:hover {
      text-decoration: underline;
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <div class="nav-links">
        <a href="index.html">üìñ Zines</a>
        <a href="timeline.html">üìÖ Timeline</a>
        <a href="stats.html" class="current">üìä Stats</a>
      </div>
      <h1>‚åö HdR Project Stats</h1>
      <p>Visualizaci√≥n de estad√≠sticas de proyectos de relojes HdR / RSWC.</p>
    </header>

    <div class="content">
      <!-- Chart Selector -->
      <div class="chart-selector">
        <label for="chartSelect">üìä Seleccionar gr√°fico:</label>
        <select id="chartSelect">
          <option value="diameter-strap">Di√°metro vs Ancho de correa</option>
          <option value="diameter-height">Di√°metro vs Grosor (altura)</option>
          <option value="diameter-lug">Di√°metro vs Lug to Lug</option>
          <option value="yearly-cumulative">Relojes por a√±o (acumulado)</option>
          <option value="yearly-units-cumulative">Unidades acumuladas por a√±os</option>
          <option value="yearly-volume-cumulative">Volumen contratado (‚Ç¨) acumulado por a√±os</option>
          <option value="price">Distribuci√≥n de precios</option>
          <option value="water-resist">Hermeticidad</option>
          <option value="movement-type">Tipos de movimiento</option>
          <option value="movement-company">Fabricante de calibre</option>
          <option value="units-production">Unidades producidas (por modelo)</option>
        </select>
      </div>

      <div class="stats-layout">
        <!-- Chart Area -->
        <div id="chartArea">
          <!-- Diameter vs Strap Width Correlation -->
          <section class="stats-card chart-section active" id="diameter-strap">
            <div>
              <h2>Correlaci√≥n: Di√°metro de caja vs Ancho de correa</h2>
              <p class="stats-meta">Relaci√≥n entre el di√°metro de caja (mm) y el ancho de correa (mm). Cada punto representa un reloj.</p>
            </div>
            <div class="chart-container">
              <canvas id="diameterStrapChart" aria-label="Gr√°fico de correlaci√≥n di√°metro-ancho" role="img"></canvas>
            </div>
            <div id="diameter-strap-error" class="error-banner"></div>
          </section>

          <!-- Diameter vs Height Correlation -->
          <section class="stats-card chart-section" id="diameter-height">
            <div>
              <h2>Correlaci√≥n: Di√°metro de caja vs Grosor</h2>
              <p class="stats-meta">Relaci√≥n entre el di√°metro de caja (mm) y el grosor/altura (mm). Cada punto representa un reloj.</p>
            </div>
            <div class="chart-container">
              <canvas id="diameterHeightChart" aria-label="Gr√°fico de correlaci√≥n di√°metro-grosor" role="img"></canvas>
            </div>
            <div id="diameter-height-error" class="error-banner"></div>
          </section>

          <!-- Diameter vs Lug to Lug Correlation -->
          <section class="stats-card chart-section" id="diameter-lug">
            <div>
              <h2>Correlaci√≥n: Di√°metro de caja vs Lug to Lug</h2>
              <p class="stats-meta">Relaci√≥n entre el di√°metro de caja (mm) y la distancia lug to lug (mm). Cada punto representa un reloj.</p>
            </div>
            <div class="chart-container">
              <canvas id="diameterLugChart" aria-label="Gr√°fico de correlaci√≥n di√°metro-lug to lug" role="img"></canvas>
            </div>
            <div id="diameter-lug-error" class="error-banner"></div>
          </section>

          <!-- Yearly Cumulative Chart -->
          <section class="stats-card chart-section" id="yearly-cumulative">
            <div>
              <h2>Evoluci√≥n acumulada de proyectos por a√±o</h2>
              <p class="stats-meta">Muestra el n√∫mero total acumulado de relojes HdR a√±o tras a√±o. Cada punto representa cu√°ntos proyectos se hab√≠an completado hasta ese a√±o.</p>
            </div>
            <div class="chart-container">
              <canvas id="yearlyChart" aria-label="Gr√°fico acumulado por a√±o" role="img"></canvas>
            </div>
            <div id="yearly-error" class="error-banner"></div>
          </section>

          <!-- Yearly Units Cumulative Chart -->
          <section class="stats-card chart-section" id="yearly-units-cumulative">
            <div>
              <h2>Unidades acumuladas por a√±os</h2>
              <p class="stats-meta">Muestra el n√∫mero total acumulado de unidades producidas a√±o tras a√±o. Incluye todas las variantes de cada reloj.</p>
            </div>
            <div class="chart-container">
              <canvas id="yearlyUnitsChart" aria-label="Gr√°fico de unidades acumuladas por a√±o" role="img"></canvas>
            </div>
            <div id="yearly-units-error" class="error-banner"></div>
          </section>

          <!-- Yearly Volume Cumulative Chart -->
          <section class="stats-card chart-section" id="yearly-volume-cumulative">
            <div>
              <h2>Volumen contratado (‚Ç¨) acumulado por a√±os</h2>
              <p class="stats-meta">Muestra el valor total acumulado de proyectos (unidades √ó precio) a√±o tras a√±o. Solo incluye proyectos con precio conocido.</p>
            </div>
            <div class="chart-container">
              <canvas id="yearlyVolumeChart" aria-label="Gr√°fico de volumen contratado acumulado por a√±o" role="img"></canvas>
            </div>
            <div id="yearly-volume-error" class="error-banner"></div>
          </section>

          <!-- Price Chart -->
          <section class="stats-card chart-section" id="price">
            <div>
              <h2>Distribuci√≥n de precios</h2>
              <p class="stats-meta">Cada punto representa un reloj individual. L√≠neas verticales cada 20‚Ç¨ marcan rangos de precio. Colores por colecci√≥n.</p>
            </div>
            <div class="chart-container">
              <canvas id="priceChart" aria-label="Distribuci√≥n de precios" role="img"></canvas>
            </div>
            <div id="price-error" class="error-banner"></div>
          </section>

          <!-- Water Resistance Chart -->
          <section class="stats-card chart-section" id="water-resist">
            <div>
              <h2>Hermeticidad</h2>
              <p class="stats-meta">Distribuci√≥n de hermeticidad como medida de presi√≥n en metros de columna de agua (escala logar√≠tmica). Cada punto representa un reloj. Colores por colecci√≥n.</p>
            </div>
            <div class="chart-container">
              <canvas id="waterResistChart" aria-label="Distribuci√≥n de hermeticidad" role="img"></canvas>
            </div>
            <div id="water-resist-error" class="error-banner"></div>
          </section>

          <!-- Movement Type Chart -->
          <section class="stats-card chart-section" id="movement-type">
            <div>
              <h2>Tipos de movimiento</h2>
              <p class="stats-meta">Conteo de relojes por tipo de movimiento (autom√°tico, cuarzo, etc.).</p>
            </div>
            <div class="chart-container">
              <canvas id="movementTypeChart" aria-label="Distribuci√≥n por tipo de movimiento" role="img"></canvas>
            </div>
            <div id="movement-type-error" class="error-banner"></div>
          </section>

          <!-- Movement Company Chart -->
          <section class="stats-card chart-section" id="movement-company">
            <div>
              <h2>Fabricante de calibre</h2>
              <p class="stats-meta">Conteo de relojes por fabricante de movimiento (Seiko, Miyota, etc.).</p>
            </div>
            <div class="chart-container">
              <canvas id="movementCompanyChart" aria-label="Distribuci√≥n por fabricante de calibre" role="img"></canvas>
            </div>
            <div id="movement-company-error" class="error-banner"></div>
          </section>

          <!-- Units Production Chart -->
          <section class="stats-card chart-section" id="units-production">
            <div>
              <h2>Unidades producidas por modelo</h2>
              <p class="stats-meta">Cantidad de unidades fabricadas de cada reloj, desglosadas por modelo cuando hay m√∫ltiples variantes.</p>
            </div>
            <div class="chart-container" style="height: 600px;">
              <canvas id="unitsProductionChart" aria-label="Unidades producidas por modelo" role="img"></canvas>
            </div>
            <div id="units-production-error" class="error-banner"></div>
          </section>
        </div>

        <!-- Summary Sidebar -->
        <aside class="stats-card">
          <div>
            <h2>Resumen del dataset</h2>
          </div>
          <div class="summary-list">
            <div class="summary-row">
              <span class="summary-label">Total de relojes</span>
              <span class="summary-value" id="stat-total-watches">‚Äì</span>
            </div>
            <div class="summary-row">
              <span class="summary-label">Con ancho entre asas</span>
              <span class="summary-value" id="stat-with-strap">‚Äì</span>
            </div>
            <div class="summary-row">
              <span class="summary-label">Sin ancho entre asas</span>
              <span class="summary-value" id="stat-missing-strap">‚Äì</span>
            </div>
            <div class="summary-row">
              <span class="summary-label">Anchos distintos</span>
              <span class="summary-value" id="stat-distinct-widths">‚Äì</span>
            </div>
          </div>
        </aside>
      </div>
    </div>

    <footer>
      <p>HdR Watch Zines ¬∑ Vista de estad√≠sticas. Datos cargados din√°micamente.</p>
      <p><a href="https://github.com/jefebus/hdr-watch-zines" target="_blank">Repositorio en GitHub</a></p>
    </footer>
  </div>

  <script>
    // Global variable to store watch data
    let globalWatchData = [];

    // Simple hash function to generate deterministic pseudo-random values from watch IDs
    function hashString(str) {
      let hash = 0;
      for (let i = 0; i < str.length; i++) {
        const char = str.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash; // Convert to 32-bit integer
      }
      // Return value between 0 and 1
      return Math.abs(hash) / 2147483647;
    }

    // Chart selector functionality
    function setupChartSelector() {
      const select = document.getElementById('chartSelect');
      const chartSections = document.querySelectorAll('.chart-section');

      select.addEventListener('change', (e) => {
        const selectedChart = e.target.value;
        
        // Save selection to localStorage
        localStorage.setItem('hdr-stats-selected-chart', selectedChart);
        
        // Hide all charts
        chartSections.forEach(section => {
          section.classList.remove('active');
        });

        // Show selected chart
        const targetSection = document.getElementById(selectedChart);
        if (targetSection) {
          targetSection.classList.add('active');
        }

        // Update summary sidebar
        updateSummaryForChart(selectedChart, globalWatchData);
      });

      // Restore last selection from localStorage (after listener is set up)
      const savedChart = localStorage.getItem('hdr-stats-selected-chart');
      if (savedChart) {
        select.value = savedChart;
        // Trigger change to show the saved chart
        const event = new Event('change');
        select.dispatchEvent(event);
      }
    }

    function showError(elementId, message) {
      const banner = document.getElementById(elementId);
      if (!banner) return;
      banner.textContent = message;
      banner.classList.add("visible");
    }

    function updateSummaryForChart(chartId, watches) {
      if (!Array.isArray(watches) || watches.length === 0) return;

      const summaryList = document.querySelector('.summary-list');
      if (!summaryList) return;

      let html = '';

      switch(chartId) {
        case 'diameter-strap':
          const withDiam = watches.filter(w => w.case_diameter != null && w.case_diameter !== "").length;
          const withStrap = watches.filter(w => w.strap_width != null && w.strap_width !== "").length;
          const withBoth = watches.filter(w => 
            w.case_diameter != null && w.case_diameter !== "" &&
            w.strap_width != null && w.strap_width !== ""
          ).length;
          
          // Calculate averages by group
          const rswcDiamStrap = watches.filter(w => w.lane_id === "rswc" && w.case_diameter != null && w.case_diameter !== "" && w.strap_width != null && w.strap_width !== "");
          const rswcAvgDiam = rswcDiamStrap.length > 0 ? (rswcDiamStrap.reduce((sum, w) => sum + parseFloat(String(w.case_diameter).replace(",", ".")), 0) / rswcDiamStrap.length).toFixed(1) : "-";
          const rswcAvgStrap = rswcDiamStrap.length > 0 ? (rswcDiamStrap.reduce((sum, w) => sum + parseFloat(String(w.strap_width).replace(",", ".")), 0) / rswcDiamStrap.length).toFixed(1) : "-";
          
          const sysDiamStrap = watches.filter(w => w.lane_id === "sys" && w.case_diameter != null && w.case_diameter !== "" && w.strap_width != null && w.strap_width !== "");
          const sysAvgDiam = sysDiamStrap.length > 0 ? (sysDiamStrap.reduce((sum, w) => sum + parseFloat(String(w.case_diameter).replace(",", ".")), 0) / sysDiamStrap.length).toFixed(1) : "-";
          const sysAvgStrap = sysDiamStrap.length > 0 ? (sysDiamStrap.reduce((sum, w) => sum + parseFloat(String(w.strap_width).replace(",", ".")), 0) / sysDiamStrap.length).toFixed(1) : "-";
          
          const otrosDiamStrap = watches.filter(w => w.lane_id === "otros" && w.case_diameter != null && w.case_diameter !== "" && w.strap_width != null && w.strap_width !== "");
          const otrosAvgDiam = otrosDiamStrap.length > 0 ? (otrosDiamStrap.reduce((sum, w) => sum + parseFloat(String(w.case_diameter).replace(",", ".")), 0) / otrosDiamStrap.length).toFixed(1) : "-";
          const otrosAvgStrap = otrosDiamStrap.length > 0 ? (otrosDiamStrap.reduce((sum, w) => sum + parseFloat(String(w.strap_width).replace(",", ".")), 0) / otrosDiamStrap.length).toFixed(1) : "-";
          
          html = `
            <div class="summary-row">
              <span class="summary-label">Total de relojes</span>
              <span class="summary-value">${watches.length}</span>
            </div>
            <div class="summary-row">
              <span class="summary-label">Con di√°metro</span>
              <span class="summary-value">${withDiam}</span>
            </div>
            <div class="summary-row">
              <span class="summary-label">Con ancho de correa</span>
              <span class="summary-value">${withStrap}</span>
            </div>
            <div class="summary-row">
              <span class="summary-label">Con ambos datos</span>
              <span class="summary-value">${withBoth}</span>
            </div>
            <div class="summary-row">
              <span class="summary-label">RSWC: √ò medio / ancho</span>
              <span class="summary-value">${rswcAvgDiam}mm / ${rswcAvgStrap}mm</span>
            </div>
            <div class="summary-row">
              <span class="summary-label">SyS: √ò medio / ancho</span>
              <span class="summary-value">${sysAvgDiam}mm / ${sysAvgStrap}mm</span>
            </div>
            <div class="summary-row">
              <span class="summary-label">Otros: √ò medio / ancho</span>
              <span class="summary-value">${otrosAvgDiam}mm / ${otrosAvgStrap}mm</span>
            </div>
          `;
          break;

        case 'diameter-height':
          const withHeight = watches.filter(w => w.case_height != null && w.case_height !== "" && w.case_height > 0).length;
          const withDiamHeight = watches.filter(w => 
            w.case_diameter != null && w.case_diameter !== "" &&
            w.case_height != null && w.case_height !== "" && w.case_height > 0
          ).length;
          
          // Calculate averages by group
          const rswcDiamHeight = watches.filter(w => w.lane_id === "rswc" && w.case_diameter != null && w.case_diameter !== "" && w.case_height != null && w.case_height !== "" && w.case_height > 0);
          const rswcAvgDiamH = rswcDiamHeight.length > 0 ? (rswcDiamHeight.reduce((sum, w) => sum + parseFloat(String(w.case_diameter).replace(",", ".")), 0) / rswcDiamHeight.length).toFixed(1) : "-";
          const rswcAvgHeight = rswcDiamHeight.length > 0 ? (rswcDiamHeight.reduce((sum, w) => sum + parseFloat(String(w.case_height).replace(",", ".")), 0) / rswcDiamHeight.length).toFixed(1) : "-";
          
          const sysDiamHeight = watches.filter(w => w.lane_id === "sys" && w.case_diameter != null && w.case_diameter !== "" && w.case_height != null && w.case_height !== "" && w.case_height > 0);
          const sysAvgDiamH = sysDiamHeight.length > 0 ? (sysDiamHeight.reduce((sum, w) => sum + parseFloat(String(w.case_diameter).replace(",", ".")), 0) / sysDiamHeight.length).toFixed(1) : "-";
          const sysAvgHeight = sysDiamHeight.length > 0 ? (sysDiamHeight.reduce((sum, w) => sum + parseFloat(String(w.case_height).replace(",", ".")), 0) / sysDiamHeight.length).toFixed(1) : "-";
          
          const otrosDiamHeight = watches.filter(w => w.lane_id === "otros" && w.case_diameter != null && w.case_diameter !== "" && w.case_height != null && w.case_height !== "" && w.case_height > 0);
          const otrosAvgDiamH = otrosDiamHeight.length > 0 ? (otrosDiamHeight.reduce((sum, w) => sum + parseFloat(String(w.case_diameter).replace(",", ".")), 0) / otrosDiamHeight.length).toFixed(1) : "-";
          const otrosAvgHeight = otrosDiamHeight.length > 0 ? (otrosDiamHeight.reduce((sum, w) => sum + parseFloat(String(w.case_height).replace(",", ".")), 0) / otrosDiamHeight.length).toFixed(1) : "-";
          
          html = `
            <div class="summary-row">
              <span class="summary-label">Total de relojes</span>
              <span class="summary-value">${watches.length}</span>
            </div>
            <div class="summary-row">
              <span class="summary-label">Con di√°metro</span>
              <span class="summary-value">${watches.filter(w => w.case_diameter != null && w.case_diameter !== "").length}</span>
            </div>
            <div class="summary-row">
              <span class="summary-label">Con grosor</span>
              <span class="summary-value">${withHeight}</span>
            </div>
            <div class="summary-row">
              <span class="summary-label">Con ambos datos</span>
              <span class="summary-value">${withDiamHeight}</span>
            </div>
            <div class="summary-row">
              <span class="summary-label">RSWC: √ò medio / grosor</span>
              <span class="summary-value">${rswcAvgDiamH}mm / ${rswcAvgHeight}mm</span>
            </div>
            <div class="summary-row">
              <span class="summary-label">SyS: √ò medio / grosor</span>
              <span class="summary-value">${sysAvgDiamH}mm / ${sysAvgHeight}mm</span>
            </div>
            <div class="summary-row">
              <span class="summary-label">Otros: √ò medio / grosor</span>
              <span class="summary-value">${otrosAvgDiamH}mm / ${otrosAvgHeight}mm</span>
            </div>
          `;
          break;

        case 'diameter-lug':
          const withLug = watches.filter(w => w.lug_to_lug != null && w.lug_to_lug !== "" && w.lug_to_lug > 0).length;
          const withDiamLug = watches.filter(w => 
            w.case_diameter != null && w.case_diameter !== "" &&
            w.lug_to_lug != null && w.lug_to_lug !== "" && w.lug_to_lug > 0
          ).length;
          
          // Calculate averages by group
          const rswcDiamLug = watches.filter(w => w.lane_id === "rswc" && w.case_diameter != null && w.case_diameter !== "" && w.lug_to_lug != null && w.lug_to_lug !== "" && w.lug_to_lug > 0);
          const rswcAvgDiamL = rswcDiamLug.length > 0 ? (rswcDiamLug.reduce((sum, w) => sum + parseFloat(String(w.case_diameter).replace(",", ".")), 0) / rswcDiamLug.length).toFixed(1) : "-";
          const rswcAvgLug = rswcDiamLug.length > 0 ? (rswcDiamLug.reduce((sum, w) => sum + parseFloat(String(w.lug_to_lug).replace(",", ".")), 0) / rswcDiamLug.length).toFixed(1) : "-";
          
          const sysDiamLug = watches.filter(w => w.lane_id === "sys" && w.case_diameter != null && w.case_diameter !== "" && w.lug_to_lug != null && w.lug_to_lug !== "" && w.lug_to_lug > 0);
          const sysAvgDiamL = sysDiamLug.length > 0 ? (sysDiamLug.reduce((sum, w) => sum + parseFloat(String(w.case_diameter).replace(",", ".")), 0) / sysDiamLug.length).toFixed(1) : "-";
          const sysAvgLug = sysDiamLug.length > 0 ? (sysDiamLug.reduce((sum, w) => sum + parseFloat(String(w.lug_to_lug).replace(",", ".")), 0) / sysDiamLug.length).toFixed(1) : "-";
          
          const otrosDiamLug = watches.filter(w => w.lane_id === "otros" && w.case_diameter != null && w.case_diameter !== "" && w.lug_to_lug != null && w.lug_to_lug !== "" && w.lug_to_lug > 0);
          const otrosAvgDiamL = otrosDiamLug.length > 0 ? (otrosDiamLug.reduce((sum, w) => sum + parseFloat(String(w.case_diameter).replace(",", ".")), 0) / otrosDiamLug.length).toFixed(1) : "-";
          const otrosAvgLug = otrosDiamLug.length > 0 ? (otrosDiamLug.reduce((sum, w) => sum + parseFloat(String(w.lug_to_lug).replace(",", ".")), 0) / otrosDiamLug.length).toFixed(1) : "-";
          
          html = `
            <div class="summary-row">
              <span class="summary-label">Total de relojes</span>
              <span class="summary-value">${watches.length}</span>
            </div>
            <div class="summary-row">
              <span class="summary-label">Con di√°metro</span>
              <span class="summary-value">${watches.filter(w => w.case_diameter != null && w.case_diameter !== "").length}</span>
            </div>
            <div class="summary-row">
              <span class="summary-label">Con lug to lug</span>
              <span class="summary-value">${withLug}</span>
            </div>
            <div class="summary-row">
              <span class="summary-label">Con ambos datos</span>
              <span class="summary-value">${withDiamLug}</span>
            </div>
            <div class="summary-row">
              <span class="summary-label">RSWC: √ò medio / lug2lug</span>
              <span class="summary-value">${rswcAvgDiamL}mm / ${rswcAvgLug}mm</span>
            </div>
            <div class="summary-row">
              <span class="summary-label">SyS: √ò medio / lug2lug</span>
              <span class="summary-value">${sysAvgDiamL}mm / ${sysAvgLug}mm</span>
            </div>
            <div class="summary-row">
              <span class="summary-label">Otros: √ò medio / lug2lug</span>
              <span class="summary-value">${otrosAvgDiamL}mm / ${otrosAvgLug}mm</span>
            </div>
          `;
          break;

        case 'yearly-cumulative':
          const years = watches.filter(w => w.year != null && w.year !== "").map(w => w.year);
          const minYear = years.length > 0 ? Math.min(...years) : 0;
          const maxYear = years.length > 0 ? Math.max(...years) : 0;
          const rswcCount = watches.filter(w => w.lane_id === "rswc").length;
          const sysCount = watches.filter(w => w.lane_id === "sys").length;
          const otrosCount = watches.filter(w => !w.lane_id || (w.lane_id !== "rswc" && w.lane_id !== "sys")).length;
          html = `
            <div class="summary-row">
              <span class="summary-label">Total de relojes</span>
              <span class="summary-value">${watches.length}</span>
            </div>
            <div class="summary-row">
              <span class="summary-label">Periodo</span>
              <span class="summary-value">${minYear} - ${maxYear}</span>
            </div>
            <div class="summary-row">
              <span class="summary-label">RSWC</span>
              <span class="summary-value">${rswcCount}</span>
            </div>
            <div class="summary-row">
              <span class="summary-label">Sol y Sombra</span>
              <span class="summary-value">${sysCount}</span>
            </div>
            <div class="summary-row">
              <span class="summary-label">Otros</span>
              <span class="summary-value">${otrosCount}</span>
            </div>
          `;
          break;

        case 'yearly-units-cumulative':
          const unitsYears = watches.filter(w => w.year != null && w.year !== "").map(w => w.year);
          const unitsMinYear = unitsYears.length > 0 ? Math.min(...unitsYears) : 0;
          const unitsMaxYear = unitsYears.length > 0 ? Math.max(...unitsYears) : 0;
          
          // Calculate total units per lane
          const rswcWatchesUnitsCum = watches.filter(w => w.lane_id === "rswc" && w.units && Array.isArray(w.units));
          const sysWatchesUnitsCum = watches.filter(w => w.lane_id === "sys" && w.units && Array.isArray(w.units));
          const otrosWatchesUnitsCum = watches.filter(w => (!w.lane_id || (w.lane_id !== "rswc" && w.lane_id !== "sys")) && w.units && Array.isArray(w.units));
          
          const rswcTotalUnitsCum = rswcWatchesUnitsCum.reduce((sum, w) => sum + w.units.reduce((s, u) => s + u, 0), 0);
          const sysTotalUnitsCum = sysWatchesUnitsCum.reduce((sum, w) => sum + w.units.reduce((s, u) => s + u, 0), 0);
          const otrosTotalUnitsCum = otrosWatchesUnitsCum.reduce((sum, w) => sum + w.units.reduce((s, u) => s + u, 0), 0);
          const grandTotalUnits = rswcTotalUnitsCum + sysTotalUnitsCum + otrosTotalUnitsCum;
          
          html = `
            <div class="summary-row">
              <span class="summary-label">Total unidades</span>
              <span class="summary-value">${grandTotalUnits}</span>
            </div>
            <div class="summary-row">
              <span class="summary-label">Periodo</span>
              <span class="summary-value">${unitsMinYear} - ${unitsMaxYear}</span>
            </div>
            <div class="summary-row">
              <span class="summary-label">RSWC units</span>
              <span class="summary-value">${rswcTotalUnitsCum}</span>
            </div>
            <div class="summary-row">
              <span class="summary-label">Sol y Sombra units</span>
              <span class="summary-value">${sysTotalUnitsCum}</span>
            </div>
            <div class="summary-row">
              <span class="summary-label">Otros units</span>
              <span class="summary-value">${otrosTotalUnitsCum}</span>
            </div>
          `;
          break;

        case 'yearly-volume-cumulative':
          const volumeYears = watches.filter(w => w.year != null && w.year !== "").map(w => w.year);
          const volumeMinYear = volumeYears.length > 0 ? Math.min(...volumeYears) : 0;
          const volumeMaxYear = volumeYears.length > 0 ? Math.max(...volumeYears) : 0;
          
          // Calculate total volume per lane (units √ó price)
          const rswcWatchesVolume = watches.filter(w => w.lane_id === "rswc" && w.units && Array.isArray(w.units) && w.price != null && typeof w.price === 'number');
          const sysWatchesVolume = watches.filter(w => w.lane_id === "sys" && w.units && Array.isArray(w.units) && w.price != null && typeof w.price === 'number');
          const otrosWatchesVolume = watches.filter(w => (!w.lane_id || (w.lane_id !== "rswc" && w.lane_id !== "sys")) && w.units && Array.isArray(w.units) && w.price != null && typeof w.price === 'number');
          
          const rswcTotalVolume = rswcWatchesVolume.reduce((sum, w) => sum + (w.units.reduce((s, u) => s + u, 0) * w.price), 0);
          const sysTotalVolume = sysWatchesVolume.reduce((sum, w) => sum + (w.units.reduce((s, u) => s + u, 0) * w.price), 0);
          const otrosTotalVolume = otrosWatchesVolume.reduce((sum, w) => sum + (w.units.reduce((s, u) => s + u, 0) * w.price), 0);
          const grandTotalVolume = rswcTotalVolume + sysTotalVolume + otrosTotalVolume;
          
          // Format numbers with thousand separators
          const formatEuro = (n) => Math.round(n).toLocaleString('es-ES') + '‚Ç¨';
          
          html = `
            <div class="summary-row">
              <span class="summary-label">Volumen total</span>
              <span class="summary-value">${formatEuro(grandTotalVolume)}</span>
            </div>
            <div class="summary-row">
              <span class="summary-label">Periodo</span>
              <span class="summary-value">${volumeMinYear} - ${volumeMaxYear}</span>
            </div>
            <div class="summary-row">
              <span class="summary-label">RSWC volumen</span>
              <span class="summary-value">${formatEuro(rswcTotalVolume)}</span>
            </div>
            <div class="summary-row">
              <span class="summary-label">Sol y Sombra volumen</span>
              <span class="summary-value">${formatEuro(sysTotalVolume)}</span>
            </div>
            <div class="summary-row">
              <span class="summary-label">Otros volumen</span>
              <span class="summary-value">${formatEuro(otrosTotalVolume)}</span>
            </div>
          `;
          break;

        case 'price':
          const withPrice = watches.filter(w => w.price != null && w.price !== "" && typeof w.price === 'number').length;
          const prices = watches.filter(w => w.price != null && w.price !== "" && typeof w.price === 'number').map(w => w.price);
          const avgPrice = prices.length > 0 ? Math.round(prices.reduce((a, b) => a + b, 0) / prices.length) : 0;
          const minPrice = prices.length > 0 ? Math.min(...prices) : 0;
          const maxPrice = prices.length > 0 ? Math.max(...prices) : 0;
          
          const rswcPrices = watches.filter(w => w.lane_id === "rswc" && w.price != null && w.price !== "" && typeof w.price === 'number').map(w => w.price);
          const avgRswcWithPrice = rswcPrices.length > 0 ? Math.round(rswcPrices.reduce((a, b) => a + b, 0) / rswcPrices.length) : 0;
          
          const sysPrices = watches.filter(w => w.lane_id === "sys" && w.price != null && w.price !== "" && typeof w.price === 'number').map(w => w.price);
          const avgSysWithPrice = sysPrices.length > 0 ? Math.round(sysPrices.reduce((a, b) => a + b, 0) / sysPrices.length) : 0;
          
          const otrosPrices = watches.filter(w => (!w.lane_id || (w.lane_id !== "rswc" && w.lane_id !== "sys")) && w.price != null && w.price !== "" && typeof w.price === 'number').map(w => w.price);
          const avgOtrosWithPrice = otrosPrices.length > 0 ? Math.round(otrosPrices.reduce((a, b) => a + b, 0) / otrosPrices.length) : 0;
          
          html = `
            <div class="summary-row">
              <span class="summary-label">Total de relojes</span>
              <span class="summary-value">${watches.length}</span>
            </div>
            <div class="summary-row">
              <span class="summary-label">Con precio</span>
              <span class="summary-value">${withPrice}</span>
            </div>
            <div class="summary-row">
              <span class="summary-label">Precio medio</span>
              <span class="summary-value">${avgPrice}‚Ç¨</span>
            </div>
            <div class="summary-row">
              <span class="summary-label">Rango</span>
              <span class="summary-value">${minPrice}‚Ç¨ - ${maxPrice}‚Ç¨</span>
            </div>
            <div class="summary-row">
              <span class="summary-label">Precio medio RSWC</span>
              <span class="summary-value">${avgRswcWithPrice}‚Ç¨</span>
            </div>
            <div class="summary-row">
              <span class="summary-label">Precio medio Sol y Sombra</span>
              <span class="summary-value">${avgSysWithPrice}‚Ç¨</span>
            </div>
            <div class="summary-row">
              <span class="summary-label">Precio medio Otros</span>
              <span class="summary-value">${avgOtrosWithPrice}‚Ç¨</span>
            </div>
          `;
          break;

        case 'water-resist':
          const withWaterResist = watches.filter(w => w.water_resist != null && w.water_resist !== "" && typeof w.water_resist === 'number').length;
          const waterResists = watches.filter(w => w.water_resist != null && w.water_resist !== "" && typeof w.water_resist === 'number').map(w => w.water_resist);
          const avgWR = waterResists.length > 0 ? Math.round(waterResists.reduce((a, b) => a + b, 0) / waterResists.length) : 0;
          const minWR = waterResists.length > 0 ? Math.min(...waterResists) : 0;
          const maxWR = waterResists.length > 0 ? Math.max(...waterResists) : 0;
          const rswcWithWR = watches.filter(w => w.lane_id === "rswc" && w.water_resist != null && w.water_resist !== "" && typeof w.water_resist === 'number').length;
          const sysWithWR = watches.filter(w => w.lane_id === "sys" && w.water_resist != null && w.water_resist !== "" && typeof w.water_resist === 'number').length;
          const otrosWithWR = watches.filter(w => (!w.lane_id || (w.lane_id !== "rswc" && w.lane_id !== "sys")) && w.water_resist != null && w.water_resist !== "" && typeof w.water_resist === 'number').length;
          html = `
            <div class="summary-row">
              <span class="summary-label">Total de relojes</span>
              <span class="summary-value">${watches.length}</span>
            </div>
            <div class="summary-row">
              <span class="summary-label">Con hermeticidad</span>
              <span class="summary-value">${withWaterResist}</span>
            </div>
            <div class="summary-row">
              <span class="summary-label">Hermeticidad media</span>
              <span class="summary-value">${avgWR}m</span>
            </div>
            <div class="summary-row">
              <span class="summary-label">Rango</span>
              <span class="summary-value">${minWR}m - ${maxWR}m</span>
            </div>
            <div class="summary-row">
              <span class="summary-label">RSWC</span>
              <span class="summary-value">${rswcWithWR}</span>
            </div>
            <div class="summary-row">
              <span class="summary-label">Sol y Sombra</span>
              <span class="summary-value">${sysWithWR}</span>
            </div>
            <div class="summary-row">
              <span class="summary-label">Otros</span>
              <span class="summary-value">${otrosWithWR}</span>
            </div>
          `;
          break;

        case 'movement-type':
          const withMovType = watches.filter(w => w.movement_type != null && w.movement_type !== "").length;
          const movTypes = [...new Set(watches.filter(w => w.movement_type != null && w.movement_type !== "").map(w => w.movement_type))];
          const automatic = watches.filter(w => w.movement_type === "automatic").length;
          const manual = watches.filter(w => w.movement_type === "manual").length;
          const quartz = watches.filter(w => w.movement_type === "quartz").length;
          const solar = watches.filter(w => w.movement_type === "solar").length;
          const anadigi = watches.filter(w => w.movement_type === "anadigi").length;
          const digital = watches.filter(w => w.movement_type === "digital").length;
          const rswcMovType = watches.filter(w => w.lane_id === "rswc" && w.movement_type != null && w.movement_type !== "").length;
          const sysMovType = watches.filter(w => w.lane_id === "sys" && w.movement_type != null && w.movement_type !== "").length;
          html = `
            <div class="summary-row">
              <span class="summary-label">Total de relojes</span>
              <span class="summary-value">${watches.length}</span>
            </div>
            <div class="summary-row">
              <span class="summary-label">Con tipo de mov.</span>
              <span class="summary-value">${withMovType}</span>
            </div>
            <div class="summary-row">
              <span class="summary-label">Tipos distintos</span>
              <span class="summary-value">${movTypes.length}</span>
            </div>
            <div class="summary-row">
              <span class="summary-label">Autom√°ticos</span>
              <span class="summary-value">${automatic}</span>
            </div>
            <div class="summary-row">
              <span class="summary-label">Manuales</span>
              <span class="summary-value">${manual}</span>
            </div>
            <div class="summary-row">
              <span class="summary-label">Cuarzo</span>
              <span class="summary-value">${quartz}</span>
            </div>
            <div class="summary-row">
              <span class="summary-label">Solar</span>
              <span class="summary-value">${solar}</span>
            </div>
            <div class="summary-row">
              <span class="summary-label">Anadigi</span>
              <span class="summary-value">${anadigi}</span>
            </div>
            <div class="summary-row">
              <span class="summary-label">Digital</span>
              <span class="summary-value">${digital}</span>
            </div>
          `;
          break;

        case 'movement-company':
          const withMovComp = watches.filter(w => w.movement_company != null && w.movement_company !== "").length;
          const movComps = [...new Set(watches.filter(w => w.movement_company != null && w.movement_company !== "").map(w => w.movement_company))];
          
          // Get most common manufacturer per group
          const getMostCommon = (arr) => {
            if (arr.length === 0) return "-";
            const counts = {};
            arr.forEach(item => counts[item] = (counts[item] || 0) + 1);
            return Object.entries(counts).sort((a, b) => b[1] - a[1])[0][0];
          };
          
          const rswcComps = watches.filter(w => w.lane_id === "rswc" && w.movement_company != null && w.movement_company !== "").map(w => w.movement_company);
          const rswcMostCommon = getMostCommon(rswcComps);
          
          const sysComps = watches.filter(w => w.lane_id === "sys" && w.movement_company != null && w.movement_company !== "").map(w => w.movement_company);
          const sysMostCommon = getMostCommon(sysComps);
          
          const otrosComps = watches.filter(w => w.lane_id === "otros" && w.movement_company != null && w.movement_company !== "").map(w => w.movement_company);
          const otrosMostCommon = getMostCommon(otrosComps);
          
          html = `
            <div class="summary-row">
              <span class="summary-label">Total de relojes</span>
              <span class="summary-value">${watches.length}</span>
            </div>
            <div class="summary-row">
              <span class="summary-label">Con fabricante</span>
              <span class="summary-value">${withMovComp}</span>
            </div>
            <div class="summary-row">
              <span class="summary-label">Fabricantes distintos</span>
              <span class="summary-value">${movComps.length}</span>
            </div>
            <div class="summary-row">
              <span class="summary-label">RSWC m√°s com√∫n</span>
              <span class="summary-value">${rswcMostCommon}</span>
            </div>
            <div class="summary-row">
              <span class="summary-label">SyS m√°s com√∫n</span>
              <span class="summary-value">${sysMostCommon}</span>
            </div>
            <div class="summary-row">
              <span class="summary-label">Otros m√°s com√∫n</span>
              <span class="summary-value">${otrosMostCommon}</span>
            </div>
          `;
          break;

        case 'units-production':
          // Filter watches with units data
          const watchesWithUnits = watches.filter(w => w && w.units && Array.isArray(w.units) && w.units.length > 0);
          
          // Calculate total units per group
          const rswcWatchesWithUnits = watchesWithUnits.filter(w => w.lane_id === "rswc");
          const sysWatchesWithUnits = watchesWithUnits.filter(w => w.lane_id === "sys");
          const otrosWatchesWithUnits = watchesWithUnits.filter(w => w.lane_id === "otros");
          
          const rswcTotalUnits = rswcWatchesWithUnits.reduce((sum, w) => sum + w.units.reduce((s, u) => s + u, 0), 0);
          const sysTotalUnits = sysWatchesWithUnits.reduce((sum, w) => sum + w.units.reduce((s, u) => s + u, 0), 0);
          const otrosTotalUnits = otrosWatchesWithUnits.reduce((sum, w) => sum + w.units.reduce((s, u) => s + u, 0), 0);
          
          // Get all individual models with their units (excluding "otros" for rankings)
          const modelsForRanking = [];
          watchesWithUnits.forEach(w => {
            if (w.models && w.units && w.models.length === w.units.length) {
              w.models.forEach((model, idx) => {
                const displayName = model && model.trim() ? `${w.title} - ${model}` : w.title;
                if (w.lane_id !== "otros") {
                  modelsForRanking.push({
                    name: displayName,
                    units: w.units[idx]
                  });
                }
              });
            }
          });
          
          // Top 5 models by units
          const top5 = [...modelsForRanking].sort((a, b) => b.units - a.units).slice(0, 5);
          
          // 5 most exclusive models (lowest units)
          const exclusive5 = [...modelsForRanking].sort((a, b) => a.units - b.units).slice(0, 5);
          
          html = `
            <div class="summary-row">
              <span class="summary-label">üèÜ RSWC</span>
              <span class="summary-value">${rswcWatchesWithUnits.length} relojes (${rswcTotalUnits} uds)</span>
            </div>
            <div class="summary-row">
              <span class="summary-label">‚öîÔ∏è Sol y Sombra</span>
              <span class="summary-value">${sysWatchesWithUnits.length} relojes (${sysTotalUnits} uds)</span>
            </div>
            <div class="summary-row">
              <span class="summary-label">üåç Otros</span>
              <span class="summary-value">${otrosWatchesWithUnits.length} relojes (${otrosTotalUnits} uds)</span>
            </div>
            <div class="summary-row" style="margin-top: 10px; border-top: 1px solid rgba(148, 163, 184, 0.2); padding-top: 10px;">
              <span class="summary-label" style="font-weight: 600;">Top 5 modelos (RSWC/RSWF/SyS)</span>
              <span class="summary-value"></span>
            </div>
            ${top5.map((m, i) => `
              <div class="summary-row" style="font-size: 0.85em;">
                <span class="summary-label">${i + 1}. ${m.name}</span>
                <span class="summary-value">${m.units} uds</span>
              </div>
            `).join('')}
            <div class="summary-row" style="margin-top: 10px; border-top: 1px solid rgba(148, 163, 184, 0.2); padding-top: 10px;">
              <span class="summary-label" style="font-weight: 600;">5 modelos m√°s exclusivos (RSWC/RSWF/SyS)</span>
              <span class="summary-value"></span>
            </div>
            ${exclusive5.map((m, i) => `
              <div class="summary-row" style="font-size: 0.85em;">
                <span class="summary-label">${i + 1}. ${m.name}</span>
                <span class="summary-value">${m.units} uds</span>
              </div>
            `).join('')}
          `;
          break;

        default:
          html = `
            <div class="summary-row">
              <span class="summary-label">Total de relojes</span>
              <span class="summary-value">${watches.length}</span>
            </div>
          `;
      }

      summaryList.innerHTML = html;
    }

    function buildDiameterStrapCorrelation(watches) {
      if (!Array.isArray(watches) || watches.length === 0) {
        showError("diameter-strap-error", "No hay datos disponibles.");
        return;
      }

      // Group data by lane_id
      const rswcData = [];
      const rswcInfo = [];
      const sysData = [];
      const sysInfo = [];
      const otrosData = [];
      const otrosInfo = [];

      for (const w of watches) {
        if (!w) continue;
        
        const diam = w.case_diameter;
        const strap = w.strap_width;
        
        if (diam === null || diam === undefined || diam === "") continue;
        if (strap === null || strap === undefined || strap === "") continue;
        
        const diamVal = typeof diam === "number" ? diam : parseFloat(String(diam).replace(",", "."));
        const strapVal = typeof strap === "number" ? strap : parseFloat(String(strap).replace(",", "."));
        
        if (!Number.isFinite(diamVal) || !Number.isFinite(strapVal)) continue;
        if (strapVal <= 0 || diamVal <= 0) continue;

        const point = { x: diamVal, y: strapVal };
        const info = {
          id: w.id || "(sin id)",
          model: w.model || w.title || w.id || "?",
          brand: w.brand || "",
          shape: w.case_shape || "round"
        };

        const laneId = w.lane_id || "otros";
        if (laneId === "rswc") {
          rswcData.push(point);
          rswcInfo.push(info);
        } else if (laneId === "sys") {
          sysData.push(point);
          sysInfo.push(info);
        } else {
          otrosData.push(point);
          otrosInfo.push(info);
        }
      }

      const totalCount = rswcData.length + sysData.length + otrosData.length;
      if (totalCount === 0) {
        showError("diameter-strap-error", "No se han encontrado relojes con ambos datos (di√°metro y ancho de correa).");
        return;
      }

      const allData = [...rswcData, ...sysData, ...otrosData];
      const diameters = allData.map(d => d.x);
      const straps = allData.map(d => d.y);
      const minDiam = Math.min(...diameters);
      const maxDiam = Math.max(...diameters);
      const minStrap = Math.min(...straps);
      const maxStrap = Math.max(...straps);

      const ctx = document.getElementById("diameterStrapChart");
      if (!ctx) {
        showError("diameter-strap-error", "No se ha encontrado el lienzo del gr√°fico.");
        return;
      }

      const datasets = [];
      const allInfo = [];

      if (rswcData.length > 0) {
        datasets.push({
          label: "RSWC",
          data: rswcData,
          backgroundColor: "rgba(218, 165, 32, 0.7)",
          borderColor: "rgba(218, 165, 32, 0.95)",
          borderWidth: 1.5,
          pointRadius: 5,
          pointHoverRadius: 7,
          pointHoverBackgroundColor: "rgba(218, 165, 32, 0.95)",
          pointStyle: rswcInfo.map(info => info.shape === "square" ? "rect" : "circle"),
          dataStartIndex: 0
        });
        allInfo.push(...rswcInfo);
      }

      if (sysData.length > 0) {
        datasets.push({
          label: "Sol y Sombra",
          data: sysData,
          backgroundColor: "rgba(139, 92, 246, 0.7)",
          borderColor: "rgba(139, 92, 246, 0.95)",
          borderWidth: 1.5,
          pointRadius: 5,
          pointHoverRadius: 7,
          pointHoverBackgroundColor: "rgba(139, 92, 246, 0.95)",
          pointStyle: sysInfo.map(info => info.shape === "square" ? "rect" : "circle"),
          dataStartIndex: rswcData.length
        });
        allInfo.push(...sysInfo);
      }

      if (otrosData.length > 0) {
        datasets.push({
          label: "Otros",
          data: otrosData,
          backgroundColor: "rgba(239, 68, 68, 0.7)",
          borderColor: "rgba(239, 68, 68, 0.95)",
          borderWidth: 1.5,
          pointRadius: 5,
          pointHoverRadius: 7,
          pointHoverBackgroundColor: "rgba(239, 68, 68, 0.95)",
          pointStyle: otrosInfo.map(info => info.shape === "square" ? "rect" : "circle"),
          dataStartIndex: rswcData.length + sysData.length
        });
        allInfo.push(...otrosInfo);
      }

      new Chart(ctx, {
        type: "scatter",
        data: {
          datasets: datasets,
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          layout: { padding: { top: 10, right: 16, left: 4, bottom: 8 } },
          scales: {
            x: {
              type: 'linear',
              min: Math.floor(minDiam - 2),
              max: Math.ceil(maxDiam + 2),
              ticks: {
                stepSize: 2,
                color: "#9ca3af",
                font: { size: 10 },
              },
              title: { display: true, text: "Di√°metro de caja (mm)", color: "#e5e7eb", font: { size: 11, weight: "500" } },
              grid: { color: "rgba(55, 65, 81, 0.3)" },
            },
            y: {
              type: 'linear',
              min: Math.floor(minStrap - 1),
              max: Math.ceil(maxStrap + 1),
              ticks: {
                stepSize: 1,
                color: "#9ca3af",
                font: { size: 10 },
              },
              title: { display: true, text: "Ancho de correa (mm)", color: "#e5e7eb", font: { size: 11, weight: "500" } },
              grid: { color: "rgba(55, 65, 81, 0.6)" },
            },
          },
          plugins: {
            legend: { 
              display: true,
              position: 'top',
              labels: { color: "#e5e7eb", font: { size: 10 } }
            },
            tooltip: {
              backgroundColor: "rgba(15, 23, 42, 0.96)",
              borderColor: "rgba(148, 163, 184, 0.7)",
              borderWidth: 1,
              padding: 10,
              titleColor: "#e5e7eb",
              bodyColor: "#e5e7eb",
              callbacks: {
                title(items) {
                  const dataset = items[0].dataset;
                  const idx = items[0].dataIndex + (dataset.dataStartIndex || 0);
                  const info = allInfo[idx];
                  return info ? info.id : "?";
                },
                label(context) {
                  const dataset = context.dataset;
                  const idx = context.dataIndex + (dataset.dataStartIndex || 0);
                  const info = allInfo[idx];
                  const displayName = info && info.brand ? `${info.brand} ${info.model}` : (info ? info.model : "?");
                  return displayName;
                },
                afterLabel(context) {
                  const diam = context.parsed.x;
                  const strap = context.parsed.y;
                  return `Di√°metro: ${diam}mm, Ancho: ${strap}mm`;
                },
              },
            },
          },
        },
      });
    }

    function buildDiameterHeightCorrelation(watches) {
      if (!Array.isArray(watches) || watches.length === 0) {
        showError("diameter-height-error", "No hay datos disponibles.");
        return;
      }

      // Group data by lane_id
      const rswcData = [];
      const rswcInfo = [];
      const sysData = [];
      const sysInfo = [];
      const otrosData = [];
      const otrosInfo = [];

      for (const w of watches) {
        if (!w) continue;
        
        const diam = w.case_diameter;
        const height = w.case_height;
        
        if (diam === null || diam === undefined || diam === "") continue;
        if (height === null || height === undefined || height === "") continue;
        
        const diamVal = typeof diam === "number" ? diam : parseFloat(String(diam).replace(",", "."));
        const heightVal = typeof height === "number" ? height : parseFloat(String(height).replace(",", "."));
        
        if (!Number.isFinite(diamVal) || !Number.isFinite(heightVal)) continue;
        if (heightVal <= 0 || diamVal <= 0) continue;

        const point = { x: diamVal, y: heightVal };
        const info = {
          id: w.id || "(sin id)",
          model: w.model || w.title || w.id || "?",
          brand: w.brand || "",
          shape: w.case_shape || "round"
        };

        const laneId = w.lane_id || "otros";
        if (laneId === "rswc") {
          rswcData.push(point);
          rswcInfo.push(info);
        } else if (laneId === "sys") {
          sysData.push(point);
          sysInfo.push(info);
        } else {
          otrosData.push(point);
          otrosInfo.push(info);
        }
      }

      const totalCount = rswcData.length + sysData.length + otrosData.length;
      if (totalCount === 0) {
        showError("diameter-height-error", "No se han encontrado relojes con ambos datos (di√°metro y grosor).");
        return;
      }

      const allData = [...rswcData, ...sysData, ...otrosData];
      const diameters = allData.map(d => d.x);
      const heights = allData.map(d => d.y);
      const minDiam = Math.min(...diameters);
      const maxDiam = Math.max(...diameters);
      const minHeight = Math.min(...heights);
      const maxHeight = Math.max(...heights);

      const ctx = document.getElementById("diameterHeightChart");
      if (!ctx) {
        showError("diameter-height-error", "No se ha encontrado el lienzo del gr√°fico.");
        return;
      }

      const datasets = [];
      const allInfo = [];

      if (rswcData.length > 0) {
        datasets.push({
          label: "RSWC",
          data: rswcData,
          backgroundColor: "rgba(218, 165, 32, 0.7)",
          borderColor: "rgba(218, 165, 32, 0.95)",
          borderWidth: 1.5,
          pointRadius: 5,
          pointHoverRadius: 7,
          pointHoverBackgroundColor: "rgba(218, 165, 32, 0.95)",
          pointStyle: rswcInfo.map(info => info.shape === "square" ? "rect" : "circle"),
          dataStartIndex: 0
        });
        allInfo.push(...rswcInfo);
      }

      if (sysData.length > 0) {
        datasets.push({
          label: "Sol y Sombra",
          data: sysData,
          backgroundColor: "rgba(139, 92, 246, 0.7)",
          borderColor: "rgba(139, 92, 246, 0.95)",
          borderWidth: 1.5,
          pointRadius: 5,
          pointHoverRadius: 7,
          pointHoverBackgroundColor: "rgba(139, 92, 246, 0.95)",
          pointStyle: sysInfo.map(info => info.shape === "square" ? "rect" : "circle"),
          dataStartIndex: rswcData.length
        });
        allInfo.push(...sysInfo);
      }

      if (otrosData.length > 0) {
        datasets.push({
          label: "Otros",
          data: otrosData,
          backgroundColor: "rgba(239, 68, 68, 0.7)",
          borderColor: "rgba(239, 68, 68, 0.95)",
          borderWidth: 1.5,
          pointRadius: 5,
          pointHoverRadius: 7,
          pointHoverBackgroundColor: "rgba(239, 68, 68, 0.95)",
          pointStyle: otrosInfo.map(info => info.shape === "square" ? "rect" : "circle"),
          dataStartIndex: rswcData.length + sysData.length
        });
        allInfo.push(...otrosInfo);
      }

      new Chart(ctx, {
        type: "scatter",
        data: {
          datasets: datasets,
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          layout: { padding: { top: 10, right: 16, left: 4, bottom: 8 } },
          scales: {
            x: {
              type: 'linear',
              min: Math.floor(minDiam - 2),
              max: Math.ceil(maxDiam + 2),
              ticks: {
                stepSize: 2,
                color: "#9ca3af",
                font: { size: 10 },
              },
              title: { display: true, text: "Di√°metro de caja (mm)", color: "#e5e7eb", font: { size: 11, weight: "500" } },
              grid: { color: "rgba(55, 65, 81, 0.3)" },
            },
            y: {
              type: 'linear',
              min: Math.floor(minHeight - 1),
              max: Math.ceil(maxHeight + 1),
              ticks: {
                stepSize: 0.5,
                color: "#9ca3af",
                font: { size: 10 },
                callback: function(value) {
                  return value % 1 === 0 ? value : value.toFixed(1);
                }
              },
              title: { display: true, text: "Grosor de caja (mm)", color: "#e5e7eb", font: { size: 11, weight: "500" } },
              grid: { color: "rgba(55, 65, 81, 0.6)" },
            },
          },
          plugins: {
            legend: { 
              display: true,
              position: 'top',
              labels: { color: "#e5e7eb", font: { size: 10 } }
            },
            tooltip: {
              backgroundColor: "rgba(15, 23, 42, 0.96)",
              borderColor: "rgba(148, 163, 184, 0.7)",
              borderWidth: 1,
              padding: 10,
              titleColor: "#e5e7eb",
              bodyColor: "#e5e7eb",
              callbacks: {
                title(items) {
                  const dataset = items[0].dataset;
                  const idx = items[0].dataIndex + (dataset.dataStartIndex || 0);
                  const info = allInfo[idx];
                  return info ? info.id : "?";
                },
                label(context) {
                  const dataset = context.dataset;
                  const idx = context.dataIndex + (dataset.dataStartIndex || 0);
                  const info = allInfo[idx];
                  const displayName = info && info.brand ? `${info.brand} ${info.model}` : (info ? info.model : "?");
                  return displayName;
                },
                afterLabel(context) {
                  const diam = context.parsed.x;
                  const height = context.parsed.y;
                  return `Di√°metro: ${diam}mm, Grosor: ${height}mm`;
                },
              },
            },
          },
        },
      });
    }

    function buildDiameterLugCorrelation(watches) {
      if (!Array.isArray(watches) || watches.length === 0) {
        showError("diameter-lug-error", "No hay datos disponibles.");
        return;
      }

      // Group data by lane_id
      const rswcData = [];
      const rswcInfo = [];
      const sysData = [];
      const sysInfo = [];
      const otrosData = [];
      const otrosInfo = [];

      for (const w of watches) {
        if (!w) continue;
        
        const diam = w.case_diameter;
        const lug = w.lug_to_lug;
        
        if (diam === null || diam === undefined || diam === "") continue;
        if (lug === null || lug === undefined || lug === "") continue;
        
        const diamVal = typeof diam === "number" ? diam : parseFloat(String(diam).replace(",", "."));
        const lugVal = typeof lug === "number" ? lug : parseFloat(String(lug).replace(",", "."));
        
        if (!Number.isFinite(diamVal) || !Number.isFinite(lugVal)) continue;
        if (lugVal <= 0 || diamVal <= 0) continue;

        const point = { x: diamVal, y: lugVal };
        const info = {
          id: w.id || "(sin id)",
          model: w.model || w.title || w.id || "?",
          brand: w.brand || "",
          shape: w.case_shape || "round"
        };

        const laneId = w.lane_id || "otros";
        if (laneId === "rswc") {
          rswcData.push(point);
          rswcInfo.push(info);
        } else if (laneId === "sys") {
          sysData.push(point);
          sysInfo.push(info);
        } else {
          otrosData.push(point);
          otrosInfo.push(info);
        }
      }

      const totalCount = rswcData.length + sysData.length + otrosData.length;
      if (totalCount === 0) {
        showError("diameter-lug-error", "No se han encontrado relojes con ambos datos (di√°metro y lug to lug).");
        return;
      }

      const allData = [...rswcData, ...sysData, ...otrosData];
      const diameters = allData.map(d => d.x);
      const lugs = allData.map(d => d.y);
      const minDiam = Math.min(...diameters);
      const maxDiam = Math.max(...diameters);
      const minLug = Math.min(...lugs);
      const maxLug = Math.max(...lugs);

      const ctx = document.getElementById("diameterLugChart");
      if (!ctx) {
        showError("diameter-lug-error", "No se ha encontrado el lienzo del gr√°fico.");
        return;
      }

      const datasets = [];
      const allInfo = [];

      if (rswcData.length > 0) {
        datasets.push({
          label: "RSWC",
          data: rswcData,
          backgroundColor: "rgba(218, 165, 32, 0.7)",
          borderColor: "rgba(218, 165, 32, 0.95)",
          borderWidth: 1.5,
          pointRadius: 5,
          pointHoverRadius: 7,
          pointHoverBackgroundColor: "rgba(218, 165, 32, 0.95)",
          pointStyle: rswcInfo.map(info => info.shape === "square" ? "rect" : "circle"),
          dataStartIndex: 0
        });
        allInfo.push(...rswcInfo);
      }

      if (sysData.length > 0) {
        datasets.push({
          label: "Sol y Sombra",
          data: sysData,
          backgroundColor: "rgba(139, 92, 246, 0.7)",
          borderColor: "rgba(139, 92, 246, 0.95)",
          borderWidth: 1.5,
          pointRadius: 5,
          pointHoverRadius: 7,
          pointHoverBackgroundColor: "rgba(139, 92, 246, 0.95)",
          pointStyle: sysInfo.map(info => info.shape === "square" ? "rect" : "circle"),
          dataStartIndex: rswcData.length
        });
        allInfo.push(...sysInfo);
      }

      if (otrosData.length > 0) {
        datasets.push({
          label: "Otros",
          data: otrosData,
          backgroundColor: "rgba(239, 68, 68, 0.7)",
          borderColor: "rgba(239, 68, 68, 0.95)",
          borderWidth: 1.5,
          pointRadius: 5,
          pointHoverRadius: 7,
          pointHoverBackgroundColor: "rgba(239, 68, 68, 0.95)",
          pointStyle: otrosInfo.map(info => info.shape === "square" ? "rect" : "circle"),
          dataStartIndex: rswcData.length + sysData.length
        });
        allInfo.push(...otrosInfo);
      }

      new Chart(ctx, {
        type: "scatter",
        data: {
          datasets: datasets,
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          layout: { padding: { top: 10, right: 16, left: 4, bottom: 8 } },
          scales: {
            x: {
              type: 'linear',
              min: Math.floor(minDiam - 2),
              max: Math.ceil(maxDiam + 2),
              ticks: {
                stepSize: 2,
                color: "#9ca3af",
                font: { size: 10 },
              },
              title: { display: true, text: "Di√°metro de caja (mm)", color: "#e5e7eb", font: { size: 11, weight: "500" } },
              grid: { color: "rgba(55, 65, 81, 0.3)" },
            },
            y: {
              type: 'linear',
              min: Math.floor(minLug - 2),
              max: Math.ceil(maxLug + 2),
              ticks: {
                stepSize: 2,
                color: "#9ca3af",
                font: { size: 10 },
              },
              title: { display: true, text: "Lug to Lug (mm)", color: "#e5e7eb", font: { size: 11, weight: "500" } },
              grid: { color: "rgba(55, 65, 81, 0.6)" },
            },
          },
          plugins: {
            legend: { 
              display: true,
              position: 'top',
              labels: { color: "#e5e7eb", font: { size: 10 } }
            },
            tooltip: {
              backgroundColor: "rgba(15, 23, 42, 0.96)",
              borderColor: "rgba(148, 163, 184, 0.7)",
              borderWidth: 1,
              padding: 10,
              titleColor: "#e5e7eb",
              bodyColor: "#e5e7eb",
              callbacks: {
                title(items) {
                  const dataset = items[0].dataset;
                  const idx = items[0].dataIndex + (dataset.dataStartIndex || 0);
                  const info = allInfo[idx];
                  return info ? info.id : "?";
                },
                label(context) {
                  const dataset = context.dataset;
                  const idx = context.dataIndex + (dataset.dataStartIndex || 0);
                  const info = allInfo[idx];
                  const displayName = info && info.brand ? `${info.brand} ${info.model}` : (info ? info.model : "?");
                  return displayName;
                },
                afterLabel(context) {
                  const diam = context.parsed.x;
                  const lug = context.parsed.y;
                  return `Di√°metro: ${diam}mm, Lug to Lug: ${lug}mm`;
                },
              },
            },
          },
        },
      });
    }

    function buildYearlyAccumulatedChart(watches) {
      if (!Array.isArray(watches) || watches.length === 0) {
        showError("yearly-error", "No hay datos disponibles.");
        return;
      }

      // Group by lane_id and year
      const rswcByYear = Object.create(null);
      const sysByYear = Object.create(null);
      const otrosByYear = Object.create(null);
      const allYears = new Set();

      for (const w of watches) {
        if (!w) continue;
        const year = w.year;
        if (year === null || year === undefined || year === "") continue;
        if (typeof year !== "number" || !Number.isFinite(year)) continue;

        allYears.add(year);
        const laneId = w.lane_id || "otros";
        const key = year.toString();

        if (laneId === "rswc") {
          rswcByYear[key] = (rswcByYear[key] || 0) + 1;
        } else if (laneId === "sys") {
          sysByYear[key] = (sysByYear[key] || 0) + 1;
        } else {
          otrosByYear[key] = (otrosByYear[key] || 0) + 1;
        }
      }

      if (allYears.size === 0) {
        showError("yearly-error", "No se han encontrado a√±os v√°lidos.");
        return;
      }

      const sortedYears = Array.from(allYears).sort((a, b) => a - b);
      const minYear = Math.min(...sortedYears);
      const maxYear = Math.max(...sortedYears);

      // Calculate cumulative data for each lane (for stacking)
      const rswcData = [];
      const sysData = [];
      const otrosData = [];
      let rswcCumulative = 0;
      let sysCumulative = 0;
      let otrosCumulative = 0;

      for (const year of sortedYears) {
        const key = year.toString();
        rswcCumulative += rswcByYear[key] || 0;
        sysCumulative += sysByYear[key] || 0;
        otrosCumulative += otrosByYear[key] || 0;

        // Push data for every year to maintain continuity
        // Store both cumulative (for display) and yearly count (for tooltip)
        rswcData.push({ x: year, y: rswcCumulative, yearlyCount: rswcByYear[key] || 0 });
        sysData.push({ x: year, y: sysCumulative, yearlyCount: sysByYear[key] || 0 });
        otrosData.push({ x: year, y: otrosCumulative, yearlyCount: otrosByYear[key] || 0 });
      }

      const ctx = document.getElementById("yearlyChart");
      if (!ctx) {
        showError("yearly-error", "No se ha encontrado el lienzo del gr√°fico.");
        return;
      }

      const datasets = [];

      // Add datasets in stacking order (bottom to top)
      if (otrosData.length > 0 && otrosCumulative > 0) {
        datasets.push({
          label: "Otros",
          data: otrosData,
          backgroundColor: "rgba(239, 68, 68, 0.6)",
          borderColor: "rgba(239, 68, 68, 0.95)",
          borderWidth: 2,
          pointRadius: 4,
          pointHoverRadius: 6,
          pointHoverBackgroundColor: "rgba(220, 38, 38, 0.95)",
          tension: 0,
          fill: true,
        });
      }

      if (sysData.length > 0 && sysCumulative > 0) {
        datasets.push({
          label: "Sol y Sombra",
          data: sysData,
          backgroundColor: "rgba(139, 92, 246, 0.6)",
          borderColor: "rgba(139, 92, 246, 0.95)",
          borderWidth: 2,
          pointRadius: 4,
          pointHoverRadius: 6,
          pointHoverBackgroundColor: "rgba(109, 40, 217, 0.95)",
          tension: 0,
          fill: true,
        });
      }

      if (rswcData.length > 0 && rswcCumulative > 0) {
        datasets.push({
          label: "RSWC",
          data: rswcData,
          backgroundColor: "rgba(218, 165, 32, 0.6)",
          borderColor: "rgba(218, 165, 32, 0.95)",
          borderWidth: 2,
          pointRadius: 4,
          pointHoverRadius: 6,
          pointHoverBackgroundColor: "rgba(184, 134, 11, 0.95)",
          tension: 0,
          fill: true,
        });
      }

      new Chart(ctx, {
        type: "line",
        data: {
          datasets: datasets,
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          interaction: {
            mode: 'index',
            intersect: false,
          },
          layout: { padding: { top: 10, right: 16, left: 4, bottom: 8 } },
          scales: {
            x: {
              type: 'linear',
              min: minYear - 1,
              max: maxYear + 1,
              ticks: {
                stepSize: 1,
                color: "#9ca3af",
                font: { size: 10 },
                callback: function(value) {
                  return Number.isInteger(value) ? value : null;
                }
              },
              title: { display: true, text: "A√±o", color: "#e5e7eb", font: { size: 11, weight: "500" } },
              grid: { color: "rgba(55, 65, 81, 0.3)" },
            },
            y: {
              stacked: true,
              beginAtZero: true,
              title: { display: true, text: "N√∫mero de relojes (acumulado)", color: "#e5e7eb", font: { size: 11, weight: "500" } },
              ticks: { 
                color: "#9ca3af", 
                precision: 0, 
                stepSize: 5, 
                font: { size: 10 },
                callback: function(value) {
                  return Number.isInteger(value) ? value : null;
                }
              },
              grid: { color: "rgba(55, 65, 81, 0.6)" },
            },
          },
          plugins: {
            legend: { 
              display: true,
              position: 'top',
              labels: { color: "#e5e7eb", font: { size: 10 } }
            },
            tooltip: {
              backgroundColor: "rgba(15, 23, 42, 0.96)",
              borderColor: "rgba(148, 163, 184, 0.7)",
              borderWidth: 1,
              padding: 10,
              titleColor: "#e5e7eb",
              bodyColor: "#e5e7eb",
              callbacks: {
                title(items) { 
                  const year = items[0].parsed.x;
                  return `A√±o ${year}`; 
                },
                label(context) { 
                  const yearlyCount = context.raw.yearlyCount || 0;
                  const lane = context.dataset.label;
                  return `${lane}: ${yearlyCount} ${yearlyCount === 1 ? "reloj" : "relojes"}`;
                },
                footer(items) {
                  // Calculate total for the specific year across all lanes
                  const total = items.reduce((sum, item) => sum + (item.raw.yearlyCount || 0), 0);
                  return `Total ese a√±o: ${total} ${total === 1 ? "reloj" : "relojes"}`;
                }
              },
            },
          },
        },
      });
    }

    function buildYearlyUnitsCumulative(watches) {
      if (!Array.isArray(watches) || watches.length === 0) {
        showError("yearly-units-error", "No hay datos disponibles.");
        return;
      }

      // Group by lane_id and year, summing units
      const rswcByYear = Object.create(null);
      const sysByYear = Object.create(null);
      const otrosByYear = Object.create(null);
      const allYears = new Set();

      for (const w of watches) {
        if (!w) continue;
        const year = w.year;
        if (year === null || year === undefined || year === "") continue;
        if (typeof year !== "number" || !Number.isFinite(year)) continue;
        
        // Sum units from the units array
        if (!w.units || !Array.isArray(w.units) || w.units.length === 0) continue;
        const totalUnits = w.units.reduce((sum, u) => sum + u, 0);
        if (totalUnits === 0) continue;

        allYears.add(year);
        const laneId = w.lane_id || "otros";
        const key = year.toString();

        if (laneId === "rswc") {
          rswcByYear[key] = (rswcByYear[key] || 0) + totalUnits;
        } else if (laneId === "sys") {
          sysByYear[key] = (sysByYear[key] || 0) + totalUnits;
        } else {
          otrosByYear[key] = (otrosByYear[key] || 0) + totalUnits;
        }
      }

      if (allYears.size === 0) {
        showError("yearly-units-error", "No se han encontrado a√±os v√°lidos con datos de unidades.");
        return;
      }

      const sortedYears = Array.from(allYears).sort((a, b) => a - b);
      const minYear = Math.min(...sortedYears);
      const maxYear = Math.max(...sortedYears);

      // Calculate cumulative data for each lane (for stacking)
      const rswcData = [];
      const sysData = [];
      const otrosData = [];
      let rswcCumulative = 0;
      let sysCumulative = 0;
      let otrosCumulative = 0;

      for (const year of sortedYears) {
        const key = year.toString();
        rswcCumulative += rswcByYear[key] || 0;
        sysCumulative += sysByYear[key] || 0;
        otrosCumulative += otrosByYear[key] || 0;

        // Push data for every year to maintain continuity
        // Store both cumulative (for display) and yearly count (for tooltip)
        rswcData.push({ x: year, y: rswcCumulative, yearlyCount: rswcByYear[key] || 0 });
        sysData.push({ x: year, y: sysCumulative, yearlyCount: sysByYear[key] || 0 });
        otrosData.push({ x: year, y: otrosCumulative, yearlyCount: otrosByYear[key] || 0 });
      }

      const ctx = document.getElementById("yearlyUnitsChart");
      if (!ctx) {
        showError("yearly-units-error", "No se ha encontrado el lienzo del gr√°fico.");
        return;
      }

      const datasets = [];

      // Add datasets in stacking order (bottom to top)
      if (otrosData.length > 0 && otrosCumulative > 0) {
        datasets.push({
          label: "Otros",
          data: otrosData,
          backgroundColor: "rgba(239, 68, 68, 0.6)",
          borderColor: "rgba(239, 68, 68, 0.95)",
          borderWidth: 2,
          pointRadius: 4,
          pointHoverRadius: 6,
          pointHoverBackgroundColor: "rgba(220, 38, 38, 0.95)",
          tension: 0,
          fill: true,
        });
      }

      if (sysData.length > 0 && sysCumulative > 0) {
        datasets.push({
          label: "Sol y Sombra",
          data: sysData,
          backgroundColor: "rgba(139, 92, 246, 0.6)",
          borderColor: "rgba(139, 92, 246, 0.95)",
          borderWidth: 2,
          pointRadius: 4,
          pointHoverRadius: 6,
          pointHoverBackgroundColor: "rgba(109, 40, 217, 0.95)",
          tension: 0,
          fill: true,
        });
      }

      if (rswcData.length > 0 && rswcCumulative > 0) {
        datasets.push({
          label: "RSWC",
          data: rswcData,
          backgroundColor: "rgba(218, 165, 32, 0.6)",
          borderColor: "rgba(218, 165, 32, 0.95)",
          borderWidth: 2,
          pointRadius: 4,
          pointHoverRadius: 6,
          pointHoverBackgroundColor: "rgba(184, 134, 11, 0.95)",
          tension: 0,
          fill: true,
        });
      }

      new Chart(ctx, {
        type: "line",
        data: {
          datasets: datasets,
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          interaction: {
            mode: 'index',
            intersect: false,
          },
          layout: { padding: { top: 10, right: 16, left: 4, bottom: 8 } },
          scales: {
            x: {
              type: 'linear',
              min: minYear - 1,
              max: maxYear + 1,
              ticks: {
                stepSize: 1,
                color: "#9ca3af",
                font: { size: 10 },
                callback: function(value) {
                  return Number.isInteger(value) ? value : null;
                }
              },
              title: { display: true, text: "A√±o", color: "#e5e7eb", font: { size: 11, weight: "500" } },
              grid: { color: "rgba(55, 65, 81, 0.3)" },
            },
            y: {
              stacked: true,
              beginAtZero: true,
              title: { display: true, text: "Unidades (acumulado)", color: "#e5e7eb", font: { size: 11, weight: "500" } },
              ticks: { 
                color: "#9ca3af", 
                precision: 0, 
                font: { size: 10 },
                callback: function(value) {
                  return Number.isInteger(value) ? value : null;
                }
              },
              grid: { color: "rgba(55, 65, 81, 0.6)" },
            },
          },
          plugins: {
            legend: { 
              display: true,
              position: 'top',
              labels: { color: "#e5e7eb", font: { size: 10 } }
            },
            tooltip: {
              backgroundColor: "rgba(15, 23, 42, 0.96)",
              borderColor: "rgba(148, 163, 184, 0.7)",
              borderWidth: 1,
              padding: 10,
              titleColor: "#e5e7eb",
              bodyColor: "#e5e7eb",
              callbacks: {
                title(items) { 
                  const year = items[0].parsed.x;
                  return `A√±o ${year}`; 
                },
                label(context) { 
                  const yearlyCount = context.raw.yearlyCount || 0;
                  const lane = context.dataset.label;
                  return `${lane}: ${yearlyCount} ${yearlyCount === 1 ? "unidad" : "unidades"}`;
                },
                footer(items) {
                  // Calculate total for the specific year across all lanes
                  const total = items.reduce((sum, item) => sum + (item.raw.yearlyCount || 0), 0);
                  return `Total ese a√±o: ${total} ${total === 1 ? "unidad" : "unidades"}`;
                }
              },
            },
          },
        },
      });
    }

    function buildYearlyVolumeCumulative(watches) {
      if (!Array.isArray(watches) || watches.length === 0) {
        showError("yearly-volume-error", "No hay datos disponibles.");
        return;
      }

      // Group by lane_id and year, calculating volume (units √ó price)
      const rswcByYear = Object.create(null);
      const sysByYear = Object.create(null);
      const otrosByYear = Object.create(null);
      const allYears = new Set();

      for (const w of watches) {
        if (!w) continue;
        const year = w.year;
        if (year === null || year === undefined || year === "") continue;
        if (typeof year !== "number" || !Number.isFinite(year)) continue;
        
        // Skip if no price or units
        if (w.price === null || w.price === undefined || typeof w.price !== 'number') continue;
        if (!w.units || !Array.isArray(w.units) || w.units.length === 0) continue;
        
        const totalUnits = w.units.reduce((sum, u) => sum + u, 0);
        if (totalUnits === 0) continue;
        
        const volume = totalUnits * w.price;
        if (volume === 0) continue;

        allYears.add(year);
        const laneId = w.lane_id || "otros";
        const key = year.toString();

        if (laneId === "rswc") {
          rswcByYear[key] = (rswcByYear[key] || 0) + volume;
        } else if (laneId === "sys") {
          sysByYear[key] = (sysByYear[key] || 0) + volume;
        } else {
          otrosByYear[key] = (otrosByYear[key] || 0) + volume;
        }
      }

      if (allYears.size === 0) {
        showError("yearly-volume-error", "No se han encontrado a√±os v√°lidos con datos de precio y unidades.");
        return;
      }

      const sortedYears = Array.from(allYears).sort((a, b) => a - b);
      const minYear = Math.min(...sortedYears);
      const maxYear = Math.max(...sortedYears);

      // Calculate cumulative data for each lane (for stacking)
      const rswcData = [];
      const sysData = [];
      const otrosData = [];
      let rswcCumulative = 0;
      let sysCumulative = 0;
      let otrosCumulative = 0;

      for (const year of sortedYears) {
        const key = year.toString();
        rswcCumulative += rswcByYear[key] || 0;
        sysCumulative += sysByYear[key] || 0;
        otrosCumulative += otrosByYear[key] || 0;

        // Push data for every year to maintain continuity
        // Store both cumulative (for display) and yearly count (for tooltip)
        rswcData.push({ x: year, y: rswcCumulative, yearlyCount: rswcByYear[key] || 0 });
        sysData.push({ x: year, y: sysCumulative, yearlyCount: sysByYear[key] || 0 });
        otrosData.push({ x: year, y: otrosCumulative, yearlyCount: otrosByYear[key] || 0 });
      }

      const ctx = document.getElementById("yearlyVolumeChart");
      if (!ctx) {
        showError("yearly-volume-error", "No se ha encontrado el lienzo del gr√°fico.");
        return;
      }

      const datasets = [];

      // Add datasets in stacking order (bottom to top)
      if (otrosData.length > 0 && otrosCumulative > 0) {
        datasets.push({
          label: "Otros",
          data: otrosData,
          backgroundColor: "rgba(239, 68, 68, 0.6)",
          borderColor: "rgba(239, 68, 68, 0.95)",
          borderWidth: 2,
          pointRadius: 4,
          pointHoverRadius: 6,
          pointHoverBackgroundColor: "rgba(220, 38, 38, 0.95)",
          tension: 0,
          fill: true,
        });
      }

      if (sysData.length > 0 && sysCumulative > 0) {
        datasets.push({
          label: "Sol y Sombra",
          data: sysData,
          backgroundColor: "rgba(139, 92, 246, 0.6)",
          borderColor: "rgba(139, 92, 246, 0.95)",
          borderWidth: 2,
          pointRadius: 4,
          pointHoverRadius: 6,
          pointHoverBackgroundColor: "rgba(109, 40, 217, 0.95)",
          tension: 0,
          fill: true,
        });
      }

      if (rswcData.length > 0 && rswcCumulative > 0) {
        datasets.push({
          label: "RSWC",
          data: rswcData,
          backgroundColor: "rgba(218, 165, 32, 0.6)",
          borderColor: "rgba(218, 165, 32, 0.95)",
          borderWidth: 2,
          pointRadius: 4,
          pointHoverRadius: 6,
          pointHoverBackgroundColor: "rgba(184, 134, 11, 0.95)",
          tension: 0,
          fill: true,
        });
      }

      new Chart(ctx, {
        type: "line",
        data: {
          datasets: datasets,
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          interaction: {
            mode: 'index',
            intersect: false,
          },
          layout: { padding: { top: 10, right: 16, left: 4, bottom: 8 } },
          scales: {
            x: {
              type: 'linear',
              min: minYear - 1,
              max: maxYear + 1,
              ticks: {
                stepSize: 1,
                color: "#9ca3af",
                font: { size: 10 },
                callback: function(value) {
                  return Number.isInteger(value) ? value : null;
                }
              },
              title: { display: true, text: "A√±o", color: "#e5e7eb", font: { size: 11, weight: "500" } },
              grid: { color: "rgba(55, 65, 81, 0.3)" },
            },
            y: {
              stacked: true,
              beginAtZero: true,
              title: { display: true, text: "Volumen ‚Ç¨ (acumulado)", color: "#e5e7eb", font: { size: 11, weight: "500" } },
              ticks: { 
                color: "#9ca3af", 
                precision: 0, 
                font: { size: 10 },
                callback: function(value) {
                  // Format with thousand separators
                  return Number.isInteger(value) ? value.toLocaleString('es-ES') + '‚Ç¨' : null;
                }
              },
              grid: { color: "rgba(55, 65, 81, 0.6)" },
            },
          },
          plugins: {
            legend: { 
              display: true,
              position: 'top',
              labels: { color: "#e5e7eb", font: { size: 10 } }
            },
            tooltip: {
              backgroundColor: "rgba(15, 23, 42, 0.96)",
              borderColor: "rgba(148, 163, 184, 0.7)",
              borderWidth: 1,
              padding: 10,
              titleColor: "#e5e7eb",
              bodyColor: "#e5e7eb",
              callbacks: {
                title(items) { 
                  const year = items[0].parsed.x;
                  return `A√±o ${year}`; 
                },
                label(context) { 
                  const yearlyCount = context.raw.yearlyCount || 0;
                  const lane = context.dataset.label;
                  return `${lane}: ${Math.round(yearlyCount).toLocaleString('es-ES')}‚Ç¨`;
                },
                footer(items) {
                  // Calculate total for the specific year across all lanes
                  const total = items.reduce((sum, item) => sum + (item.raw.yearlyCount || 0), 0);
                  return `Total ese a√±o: ${Math.round(total).toLocaleString('es-ES')}‚Ç¨`;
                }
              },
            },
          },
        },
      });
    }

    function buildStrapWidthHistogram(watches) {
      if (!Array.isArray(watches) || watches.length === 0) {
        showError("strap-width-error", "No hay datos disponibles.");
        return;
      }

      const bucketCounts = Object.create(null);
      const idsByWidth = Object.create(null);

      for (const w of watches) {
        if (!w) continue;
        let raw = w.strap_width;
        if (raw === null || raw === undefined || raw === "") continue;
        if (typeof raw !== "number") {
          raw = parseFloat(String(raw).replace(",", "."));
        }
        if (!Number.isFinite(raw)) continue;

        const key = raw.toString();
        bucketCounts[key] = (bucketCounts[key] || 0) + 1;
        if (!idsByWidth[key]) idsByWidth[key] = [];
        idsByWidth[key].push(w.id || "(no id)");
      }

      if (Object.keys(bucketCounts).length === 0) {
        showError("strap-width-error", "No se han encontrado anchos de correa v√°lidos.");
        return;
      }

      // Prepare line data points
      const widths = Object.keys(bucketCounts).map(Number).sort((a, b) => a - b);
      const lineData = widths.map(w => ({ x: w, y: bucketCounts[w.toString()] }));
      
      const minWidth = Math.min(...widths);
      const maxWidth = Math.max(...widths);

      const ctx = document.getElementById("strapWidthChart");
      if (!ctx) {
        showError("strap-width-error", "No se ha encontrado el lienzo del gr√°fico.");
        return;
      }

      new Chart(ctx, {
        type: "line",
        data: {
          datasets: [{
            label: "Relojes",
            data: lineData,
            backgroundColor: "rgba(218, 165, 32, 0.7)",
            borderColor: "rgba(218, 165, 32, 0.95)",
            borderWidth: 2,
            pointRadius: 6,
            pointHoverRadius: 8,
            pointHoverBackgroundColor: "rgba(184, 134, 11, 0.95)",
            tension: 0,
            fill: false,
          }],
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          layout: { padding: { top: 10, right: 16, left: 4, bottom: 8 } },
          scales: {
            x: {
              type: 'linear',
              min: Math.floor(minWidth - 1),
              max: Math.ceil(maxWidth + 1),
              ticks: {
                stepSize: 0.5,
                color: "#9ca3af",
                font: { size: 10 },
                callback: function(value) {
                  return value % 1 === 0 ? value : value.toFixed(1);
                }
              },
              title: { display: true, text: "Ancho de correa (mm)", color: "#e5e7eb", font: { size: 11, weight: "500" } },
              grid: { color: "rgba(55, 65, 81, 0.3)" },
            },
            y: {
              beginAtZero: true,
              title: { display: true, text: "N√∫mero de relojes", color: "#e5e7eb", font: { size: 11, weight: "500" } },
              ticks: { 
                color: "#9ca3af", 
                precision: 0, 
                stepSize: 1, 
                font: { size: 10 },
                callback: function(value) {
                  return Number.isInteger(value) ? value : null;
                }
              },
              grid: { color: "rgba(55, 65, 81, 0.6)" },
            },
          },
          plugins: {
            legend: { display: false },
            tooltip: {
              backgroundColor: "rgba(15, 23, 42, 0.96)",
              borderColor: "rgba(148, 163, 184, 0.7)",
              borderWidth: 1,
              padding: 10,
              titleColor: "#e5e7eb",
              bodyColor: "#e5e7eb",
              callbacks: {
                title(items) { 
                  const width = items[0].parsed.x;
                  return `Ancho de correa: ${width} mm`; 
                },
                label(context) { 
                  return `${context.parsed.y} ${context.parsed.y === 1 ? "reloj" : "relojes"}`; 
                },
                afterBody(items) {
                  const width = items[0].parsed.x.toString();
                  const ids = idsByWidth[width] || [];
                  if (!ids.length) return "";
                  const shown = ids.slice(0, 14);
                  const remaining = ids.length - shown.length;
                  return `IDs: ${shown.join(", ")}${remaining > 0 ? ` ‚Ä¶ (+${remaining} m√°s)` : ""}`;
                },
              },
            },
          },
        },
      });
    }

    function buildCaseHeightLine(watches) {
      if (!Array.isArray(watches) || watches.length === 0) {
        showError("case-height-error", "No hay datos disponibles.");
        return;
      }

      const heightCounts = Object.create(null);
      const idsByHeight = Object.create(null);

      for (const w of watches) {
        if (!w) continue;
        const height = w.case_height;
        if (height === null || height === undefined || height === "") continue;
        if (typeof height !== "number" || !Number.isFinite(height)) continue;

        const key = height.toString();
        heightCounts[key] = (heightCounts[key] || 0) + 1;
        if (!idsByHeight[key]) idsByHeight[key] = [];
        idsByHeight[key].push(w.id || "(sin id)");
      }

      if (Object.keys(heightCounts).length === 0) {
        showError("case-height-error", "No se han encontrado grosores v√°lidos.");
        return;
      }

      const heights = Object.keys(heightCounts).map(Number).sort((a, b) => a - b);
      const lineData = heights.map(h => ({ x: h, y: heightCounts[h.toString()] }));
      
      const minHeight = Math.min(...heights);
      const maxHeight = Math.max(...heights);

      const ctx = document.getElementById("caseHeightChart");
      if (!ctx) {
        showError("case-height-error", "No se ha encontrado el lienzo del gr√°fico.");
        return;
      }

      new Chart(ctx, {
        type: "line",
        data: {
          datasets: [{
            label: "Relojes",
            data: lineData,
            backgroundColor: "rgba(52, 211, 153, 0.7)",
            borderColor: "rgba(16, 185, 129, 0.95)",
            borderWidth: 2,
            pointRadius: 6,
            pointHoverRadius: 8,
            pointHoverBackgroundColor: "rgba(16, 185, 129, 0.95)",
            tension: 0,
            fill: false,
          }],
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          layout: { padding: { top: 10, right: 16, left: 4, bottom: 8 } },
          scales: {
            x: {
              type: 'linear',
              min: Math.floor(minHeight - 1),
              max: Math.ceil(maxHeight + 1),
              ticks: {
                stepSize: 0.5,
                color: "#9ca3af",
                font: { size: 10 },
                callback: function(value) {
                  return value % 1 === 0 ? value : value.toFixed(1);
                }
              },
              title: { display: true, text: "Grosor de caja (mm)", color: "#e5e7eb", font: { size: 11, weight: "500" } },
              grid: { color: "rgba(55, 65, 81, 0.3)" },
            },
            y: {
              beginAtZero: true,
              title: { display: true, text: "N√∫mero de relojes", color: "#e5e7eb", font: { size: 11, weight: "500" } },
              ticks: { 
                color: "#9ca3af", 
                precision: 0, 
                stepSize: 1, 
                font: { size: 10 },
                callback: function(value) {
                  return Number.isInteger(value) ? value : null;
                }
              },
              grid: { color: "rgba(55, 65, 81, 0.6)" },
            },
          },
          plugins: {
            legend: { display: false },
            tooltip: {
              backgroundColor: "rgba(15, 23, 42, 0.96)",
              borderColor: "rgba(148, 163, 184, 0.7)",
              borderWidth: 1,
              padding: 10,
              titleColor: "#e5e7eb",
              bodyColor: "#e5e7eb",
              callbacks: {
                title(items) { 
                  const height = items[0].parsed.x;
                  return `Grosor: ${height} mm`; 
                },
                label(context) { 
                  return `${context.parsed.y} ${context.parsed.y === 1 ? "reloj" : "relojes"}`; 
                },
                afterBody(items) {
                  const height = items[0].parsed.x.toString();
                  const ids = idsByHeight[height] || [];
                  if (!ids.length) return "";
                  const shown = ids.slice(0, 14);
                  const remaining = ids.length - shown.length;
                  return `IDs: ${shown.join(", ")}${remaining > 0 ? ` ‚Ä¶ (+${remaining} m√°s)` : ""}`;
                },
              },
            },
          },
        },
      });
    }

    function buildPriceLine(watches) {
      if (!Array.isArray(watches) || watches.length === 0) {
        showError("price-error", "No hay datos disponibles.");
        return;
      }

      // Group watches by lane_id with price data
      const rswcData = [];
      const rswcInfo = [];
      const sysData = [];
      const sysInfo = [];
      const otrosData = [];
      const otrosInfo = [];

      for (const w of watches) {
        if (!w) continue;
        const price = w.price;
        if (price === null || price === undefined || price === "") continue;
        if (typeof price !== "number" || !Number.isFinite(price)) continue;

        const info = {
          id: w.id || "(sin id)",
          model: w.model || w.title || w.id || "?",
          brand: w.brand || "",
          price: price
        };

        const laneId = w.lane_id || "otros";
        if (laneId === "rswc") {
          rswcInfo.push(info);
        } else if (laneId === "sys") {
          sysInfo.push(info);
        } else {
          otrosInfo.push(info);
        }
      }

      const totalCount = rswcInfo.length + sysInfo.length + otrosInfo.length;
      if (totalCount === 0) {
        showError("price-error", "No se han encontrado precios v√°lidos.");
        return;
      }

      // Sort each group by price
      rswcInfo.sort((a, b) => a.price - b.price);
      sysInfo.sort((a, b) => a.price - b.price);
      otrosInfo.sort((a, b) => a.price - b.price);

      // Create scatter data with jitter to prevent overlapping
      const jitterAmount = 0.3; // Small horizontal displacement
      
      // Helper function to add jitter
      const createScatterPoints = (infoArray, baseY) => {
        const priceCount = new Map();
        return infoArray.map(info => {
          const price = info.price;
          const count = priceCount.get(price) || 0;
          priceCount.set(price, count + 1);
          
          // Add deterministic jitter based on watch ID
          const jitter = (hashString(info.id) - 0.5) * jitterAmount * 2;
          return { x: price, y: baseY + jitter };
        });
      };

      // Assign different X levels for each lane to spread them out
      if (rswcInfo.length > 0) {
        rswcData.push(...createScatterPoints(rswcInfo, 2).map(p => ({x: p.y, y: p.x})));
      }
      if (sysInfo.length > 0) {
        sysData.push(...createScatterPoints(sysInfo, 1).map(p => ({x: p.y, y: p.x})));
      }
      if (otrosInfo.length > 0) {
        otrosData.push(...createScatterPoints(otrosInfo, 0).map(p => ({x: p.y, y: p.x})));
      }

      // Get price range
      const allPrices = [...rswcInfo, ...sysInfo, ...otrosInfo].map(i => i.price);
      const minPrice = Math.min(...allPrices);
      const maxPrice = Math.max(...allPrices);

      const ctx = document.getElementById("priceChart");
      if (!ctx) {
        showError("price-error", "No se ha encontrado el lienzo del gr√°fico.");
        return;
      }

      const datasets = [];
      const allInfo = [];

      if (otrosData.length > 0) {
        datasets.push({
          label: "Otros",
          data: otrosData,
          backgroundColor: "rgba(239, 68, 68, 0.7)",
          borderColor: "rgba(239, 68, 68, 0.95)",
          borderWidth: 1.5,
          pointRadius: 5,
          pointHoverRadius: 7,
          pointHoverBackgroundColor: "rgba(239, 68, 68, 0.95)",
          dataStartIndex: 0
        });
        allInfo.push(...otrosInfo);
      }

      if (sysData.length > 0) {
        datasets.push({
          label: "Sol y Sombra",
          data: sysData,
          backgroundColor: "rgba(139, 92, 246, 0.7)",
          borderColor: "rgba(139, 92, 246, 0.95)",
          borderWidth: 1.5,
          pointRadius: 5,
          pointHoverRadius: 7,
          pointHoverBackgroundColor: "rgba(139, 92, 246, 0.95)",
          dataStartIndex: otrosInfo.length
        });
        allInfo.push(...sysInfo);
      }

      if (rswcData.length > 0) {
        datasets.push({
          label: "RSWC",
          data: rswcData,
          backgroundColor: "rgba(218, 165, 32, 0.7)",
          borderColor: "rgba(218, 165, 32, 0.95)",
          borderWidth: 1.5,
          pointRadius: 5,
          pointHoverRadius: 7,
          pointHoverBackgroundColor: "rgba(218, 165, 32, 0.95)",
          dataStartIndex: otrosInfo.length + sysInfo.length
        });
        allInfo.push(...rswcInfo);
      }

      // Calculate grid lines for 20‚Ç¨ intervals
      const minGridPrice = Math.floor(minPrice / 20) * 20;
      const maxGridPrice = Math.ceil(maxPrice / 20) * 20;

      new Chart(ctx, {
        type: "scatter",
        data: {
          datasets: datasets,
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          layout: { padding: { top: 10, right: 16, left: 4, bottom: 8 } },
          scales: {
            x: {
              display: false, // Hide X axis as it's just for jitter
              min: -0.5,
              max: 2.5,
            },
            y: {
              type: 'linear',
              min: Math.max(0, minGridPrice - 20),
              max: maxGridPrice + 20,
              ticks: {
                stepSize: 20,
                color: "#9ca3af",
                font: { size: 10 },
                callback: function(value) {
                  return value + '‚Ç¨';
                }
              },
              title: { display: true, text: "Precio (‚Ç¨)", color: "#e5e7eb", font: { size: 11, weight: "500" } },
              grid: { 
                color: function(context) {
                  // Highlight every 20‚Ç¨ with a stronger line
                  return context.tick.value % 20 === 0 ? "rgba(148, 163, 184, 0.4)" : "rgba(55, 65, 81, 0.2)";
                },
                lineWidth: function(context) {
                  return context.tick.value % 20 === 0 ? 1.5 : 0.5;
                }
              },
            },
          },
          plugins: {
            legend: { 
              display: true,
              position: 'top',
              labels: { color: "#e5e7eb", font: { size: 10 } }
            },
            tooltip: {
              backgroundColor: "rgba(15, 23, 42, 0.96)",
              borderColor: "rgba(148, 163, 184, 0.7)",
              borderWidth: 1,
              padding: 10,
              titleColor: "#e5e7eb",
              bodyColor: "#e5e7eb",
              callbacks: {
                title(items) {
                  const dataset = items[0].dataset;
                  const idx = items[0].dataIndex + (dataset.dataStartIndex || 0);
                  const info = allInfo[idx];
                  return info ? info.id : "?";
                },
                label(context) {
                  const dataset = context.dataset;
                  const idx = context.dataIndex + (dataset.dataStartIndex || 0);
                  const info = allInfo[idx];
                  const displayName = info && info.brand ? `${info.brand} ${info.model}` : (info ? info.model : "?");
                  return displayName;
                },
                afterLabel(context) {
                  const dataset = context.dataset;
                  const idx = context.dataIndex + (dataset.dataStartIndex || 0);
                  const info = allInfo[idx];
                  const price = info ? info.price : context.parsed.y;
                  const priceRange = Math.floor(price / 20) * 20;
                  return [
                    `Precio: ${price}‚Ç¨`,
                    `Rango: ${priceRange}‚Ç¨ - ${priceRange + 20}‚Ç¨`
                  ];
                },
              },
            },
          },
        },
      });
    }

    function buildWaterResistChart(watches) {
      if (!Array.isArray(watches) || watches.length === 0) {
        showError("water-resist-error", "No hay datos disponibles.");
        return;
      }

      // Group watches by lane_id with water_resist data
      const rswcData = [];
      const rswcInfo = [];
      const sysData = [];
      const sysInfo = [];
      const otrosData = [];
      const otrosInfo = [];

      for (const w of watches) {
        if (!w) continue;
        const waterResist = w.water_resist;
        if (waterResist === null || waterResist === undefined || waterResist === "") continue;
        if (typeof waterResist !== "number" || !Number.isFinite(waterResist) || waterResist <= 0) continue;

        const info = {
          id: w.id || "(sin id)",
          model: w.model || w.title || w.id || "?",
          brand: w.brand || "",
          water_resist: waterResist
        };

        const laneId = w.lane_id || "otros";
        if (laneId === "rswc") {
          rswcInfo.push(info);
        } else if (laneId === "sys") {
          sysInfo.push(info);
        } else {
          otrosInfo.push(info);
        }
      }

      const totalCount = rswcInfo.length + sysInfo.length + otrosInfo.length;
      if (totalCount === 0) {
        showError("water-resist-error", "No se han encontrado valores de resistencia al agua v√°lidos.");
        return;
      }

      // Sort each group by water resistance
      rswcInfo.sort((a, b) => a.water_resist - b.water_resist);
      sysInfo.sort((a, b) => a.water_resist - b.water_resist);
      otrosInfo.sort((a, b) => a.water_resist - b.water_resist);

      // Create scatter data with jitter to prevent overlapping
      const jitterAmount = 0.3;
      
      const createScatterPoints = (infoArray, baseY) => {
        const wrCount = new Map();
        return infoArray.map(info => {
          const wr = info.water_resist;
          const count = wrCount.get(wr) || 0;
          wrCount.set(wr, count + 1);
          
          // Add deterministic jitter based on watch ID
          const jitter = (hashString(info.id) - 0.5) * jitterAmount * 2;
          return { x: baseY + jitter, y: wr };
        });
      };

      // Assign different X levels for each lane
      if (rswcInfo.length > 0) {
        rswcData.push(...createScatterPoints(rswcInfo, 2));
      }
      if (sysInfo.length > 0) {
        sysData.push(...createScatterPoints(sysInfo, 1));
      }
      if (otrosInfo.length > 0) {
        otrosData.push(...createScatterPoints(otrosInfo, 0));
      }

      // Get water resistance range
      const allWR = [...rswcInfo, ...sysInfo, ...otrosInfo].map(i => i.water_resist);
      const minWR = Math.min(...allWR);
      const maxWR = Math.max(...allWR);

      const ctx = document.getElementById("waterResistChart");
      if (!ctx) {
        showError("water-resist-error", "No se ha encontrado el lienzo del gr√°fico.");
        return;
      }

      const datasets = [];
      const allInfo = [];

      if (otrosData.length > 0) {
        datasets.push({
          label: "Otros",
          data: otrosData,
          backgroundColor: "rgba(239, 68, 68, 0.7)",
          borderColor: "rgba(239, 68, 68, 0.95)",
          borderWidth: 1.5,
          pointRadius: 5,
          pointHoverRadius: 7,
          pointHoverBackgroundColor: "rgba(239, 68, 68, 0.95)",
          dataStartIndex: 0
        });
        allInfo.push(...otrosInfo);
      }

      if (sysData.length > 0) {
        datasets.push({
          label: "Sol y Sombra",
          data: sysData,
          backgroundColor: "rgba(139, 92, 246, 0.7)",
          borderColor: "rgba(139, 92, 246, 0.95)",
          borderWidth: 1.5,
          pointRadius: 5,
          pointHoverRadius: 7,
          pointHoverBackgroundColor: "rgba(139, 92, 246, 0.95)",
          dataStartIndex: otrosInfo.length
        });
        allInfo.push(...sysInfo);
      }

      if (rswcData.length > 0) {
        datasets.push({
          label: "RSWC",
          data: rswcData,
          backgroundColor: "rgba(218, 165, 32, 0.7)",
          borderColor: "rgba(218, 165, 32, 0.95)",
          borderWidth: 1.5,
          pointRadius: 5,
          pointHoverRadius: 7,
          pointHoverBackgroundColor: "rgba(218, 165, 32, 0.95)",
          dataStartIndex: otrosInfo.length + sysInfo.length
        });
        allInfo.push(...rswcInfo);
      }

      new Chart(ctx, {
        type: "scatter",
        data: {
          datasets: datasets,
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          layout: { padding: { top: 10, right: 16, left: 4, bottom: 8 } },
          scales: {
            x: {
              display: false, // Hide X axis as it's just for jitter
              min: -0.5,
              max: 2.5,
            },
            y: {
              type: 'logarithmic',
              min: Math.max(1, minWR / 2),
              max: maxWR * 2,
              afterBuildTicks: function(axis) {
                // Generate comprehensive tick values including 2, 3, 5, 7 multiples
                const ticks = [];
                const minLog = Math.floor(Math.log10(axis.min));
                const maxLog = Math.ceil(Math.log10(axis.max));
                
                for (let exp = minLog; exp <= maxLog; exp++) {
                  const base = Math.pow(10, exp);
                  // Add 1x, 2x, 3x, 5x, 7x for each power of 10
                  [1, 2, 3, 5, 7].forEach(mult => {
                    const value = base * mult;
                    if (value >= axis.min && value <= axis.max) {
                      ticks.push({ value: value });
                    }
                  });
                }
                
                // Sort and deduplicate
                axis.ticks = ticks.sort((a, b) => a.value - b.value);
              },
              ticks: {
                autoSkip: false,
                color: function(context) {
                  const value = context.tick.value;
                  const logVal = Math.log10(value);
                  // Major ticks (powers of 10) in brighter color
                  if (Math.abs(logVal - Math.round(logVal)) < 0.01) {
                    return "#9ca3af";
                  }
                  // Minor ticks in dimmer color
                  return "#6b7280";
                },
                font: function(context) {
                  const value = context.tick.value;
                  const logVal = Math.log10(value);
                  // Major ticks larger
                  if (Math.abs(logVal - Math.round(logVal)) < 0.01) {
                    return { size: 10, weight: '600' };
                  }
                  // Minor ticks smaller
                  return { size: 9 };
                },
                callback: function(value) {
                  const logVal = Math.log10(value);
                  // Always show powers of 10 (1, 10, 100, 1000...)
                  if (Math.abs(logVal - Math.round(logVal)) < 0.01) {
                    return value + 'm';
                  }
                  
                  // For intermediate values, check if it's 2, 3, 5, or 7 times a power of 10
                  const powerOf10 = Math.pow(10, Math.floor(logVal));
                  const multiplier = value / powerOf10;
                  
                  // Show 2x, 3x, 5x, 7x of each power of 10
                  if (Math.abs(multiplier - 2) < 0.01 || 
                      Math.abs(multiplier - 3) < 0.01 || 
                      Math.abs(multiplier - 5) < 0.01 || 
                      Math.abs(multiplier - 7) < 0.01) {
                    return value + 'm';
                  }
                  
                  return '';
                }
              },
              title: { display: true, text: "Resistencia al agua (m, escala logar√≠tmica)", color: "#e5e7eb", font: { size: 11, weight: "500" } },
              grid: { 
                color: function(context) {
                  const value = context.tick.value;
                  const logVal = Math.log10(value);
                  // Major grid lines (powers of 10)
                  if (Math.abs(logVal - Math.round(logVal)) < 0.01) {
                    return "rgba(148, 163, 184, 0.5)";
                  }
                  
                  // Minor grid lines for 2x, 3x, 5x, 7x multiples
                  const powerOf10 = Math.pow(10, Math.floor(logVal));
                  const multiplier = value / powerOf10;
                  if (Math.abs(multiplier - 2) < 0.01 || 
                      Math.abs(multiplier - 3) < 0.01 || 
                      Math.abs(multiplier - 5) < 0.01 || 
                      Math.abs(multiplier - 7) < 0.01) {
                    return "rgba(100, 116, 139, 0.3)";
                  }
                  
                  return "rgba(55, 65, 81, 0.15)";
                },
                lineWidth: function(context) {
                  const value = context.tick.value;
                  const logVal = Math.log10(value);
                  // Major grid lines thicker
                  if (Math.abs(logVal - Math.round(logVal)) < 0.01) {
                    return 1.5;
                  }
                  
                  // Intermediate values medium thickness
                  const powerOf10 = Math.pow(10, Math.floor(logVal));
                  const multiplier = value / powerOf10;
                  if (Math.abs(multiplier - 2) < 0.01 || 
                      Math.abs(multiplier - 3) < 0.01 || 
                      Math.abs(multiplier - 5) < 0.01 || 
                      Math.abs(multiplier - 7) < 0.01) {
                    return 1;
                  }
                  
                  return 0.5;
                }
              },
            },
          },
          plugins: {
            legend: { 
              display: true,
              position: 'top',
              labels: { color: "#e5e7eb", font: { size: 10 } }
            },
            tooltip: {
              backgroundColor: "rgba(15, 23, 42, 0.96)",
              borderColor: "rgba(148, 163, 184, 0.7)",
              borderWidth: 1,
              padding: 10,
              titleColor: "#e5e7eb",
              bodyColor: "#e5e7eb",
              callbacks: {
                title(items) {
                  const dataset = items[0].dataset;
                  const idx = items[0].dataIndex + (dataset.dataStartIndex || 0);
                  const info = allInfo[idx];
                  return info ? info.id : "?";
                },
                label(context) {
                  const dataset = context.dataset;
                  const idx = context.dataIndex + (dataset.dataStartIndex || 0);
                  const info = allInfo[idx];
                  const displayName = info && info.brand ? `${info.brand} ${info.model}` : (info ? info.model : "?");
                  return displayName;
                },
                afterLabel(context) {
                  const dataset = context.dataset;
                  const idx = context.dataIndex + (dataset.dataStartIndex || 0);
                  const info = allInfo[idx];
                  const wr = info ? info.water_resist : context.parsed.y;
                  const atm = Math.round(wr / 10);
                  return [
                    `Resistencia: ${wr}m (${atm} ATM)`
                  ];
                },
              },
            },
          },
        },
      });
    }

    function buildCaseDiameterScatter(watches) {
      if (!Array.isArray(watches) || watches.length === 0) {
        showError("case-diameter-error", "No hay datos disponibles.");
        return;
      }

      const diameterCounts = Object.create(null);
      const idsByDiameter = Object.create(null);

      for (const w of watches) {
        if (!w) continue;
        const diam = w.case_diameter;
        if (diam === null || diam === undefined || diam === "") continue;
        if (typeof diam !== "number" || !Number.isFinite(diam)) continue;

        const key = diam.toString();
        diameterCounts[key] = (diameterCounts[key] || 0) + 1;
        if (!idsByDiameter[key]) idsByDiameter[key] = [];
        idsByDiameter[key].push(w.id || "(sin id)");
      }

      if (Object.keys(diameterCounts).length === 0) {
        showError("case-diameter-error", "No se han encontrado di√°metros v√°lidos.");
        return;
      }

      // Prepare scatter data points
      const scatterData = [];
      const diameters = Object.keys(diameterCounts).map(Number).sort((a, b) => a - b);
      
      for (const diam of diameters) {
        scatterData.push({ x: diam, y: diameterCounts[diam.toString()] });
      }

      const minDiam = Math.min(...diameters);
      const maxDiam = Math.max(...diameters);

      const ctx = document.getElementById("caseDiameterChart");
      if (!ctx) {
        showError("case-diameter-error", "No se ha encontrado el lienzo del gr√°fico.");
        return;
      }

      new Chart(ctx, {
        type: "line",
        data: {
          datasets: [{
            label: "Relojes",
            data: scatterData,
            backgroundColor: "rgba(56, 189, 248, 0.7)",
            borderColor: "rgba(56, 189, 248, 0.95)",
            borderWidth: 2,
            pointRadius: 6,
            pointHoverRadius: 8,
            pointHoverBackgroundColor: "rgba(56, 189, 248, 0.95)",
            tension: 0,
            fill: false,
          }],
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          layout: { padding: { top: 10, right: 16, left: 4, bottom: 8 } },
          scales: {
            x: {
              type: 'linear',
              min: Math.floor(minDiam - 1),
              max: Math.ceil(maxDiam + 1),
              ticks: {
                stepSize: 0.5,
                color: "#9ca3af",
                font: { size: 10 },
                callback: function(value) {
                  return value % 1 === 0 ? value : value.toFixed(1);
                }
              },
              title: { display: true, text: "Di√°metro de caja (mm)", color: "#e5e7eb", font: { size: 11, weight: "500" } },
              grid: { color: "rgba(55, 65, 81, 0.3)" },
            },
            y: {
              beginAtZero: true,
              title: { display: true, text: "N√∫mero de relojes", color: "#e5e7eb", font: { size: 11, weight: "500" } },
              ticks: { 
                color: "#9ca3af", 
                precision: 0, 
                stepSize: 1, 
                font: { size: 10 },
                callback: function(value) {
                  return Number.isInteger(value) ? value : null;
                }
              },
              grid: { color: "rgba(55, 65, 81, 0.6)" },
            },
          },
          plugins: {
            legend: { display: false },
            tooltip: {
              backgroundColor: "rgba(15, 23, 42, 0.96)",
              borderColor: "rgba(148, 163, 184, 0.7)",
              borderWidth: 1,
              padding: 10,
              titleColor: "#e5e7eb",
              bodyColor: "#e5e7eb",
              callbacks: {
                title(items) { 
                  const diam = items[0].parsed.x;
                  return `Di√°metro: ${diam} mm`; 
                },
                label(context) { 
                  return `${context.parsed.y} ${context.parsed.y === 1 ? "reloj" : "relojes"}`; 
                },
                afterBody(items) {
                  const diam = items[0].parsed.x.toString();
                  const ids = idsByDiameter[diam] || [];
                  if (!ids.length) return "";
                  const shown = ids.slice(0, 14);
                  const remaining = ids.length - shown.length;
                  return `IDs: ${shown.join(", ")}${remaining > 0 ? ` ‚Ä¶ (+${remaining} m√°s)` : ""}`;
                },
              },
            },
          },
        },
      });
    }

    function buildChart(watches, config) {
      const { chartId, errorId, field, title, xLabel, yLabel, color, borderColor } = config;
      
      if (!Array.isArray(watches) || watches.length === 0) {
        showError(errorId, "No hay datos disponibles.");
        return;
      }

      // Group by value and lane_id
      const rswcCounts = Object.create(null);
      const sysCounts = Object.create(null);
      const otrosCounts = Object.create(null);
      const allValues = new Set();

      for (const w of watches) {
        if (!w) continue;
        let raw = w[field];
        if (raw === null || raw === undefined || raw === "") continue;
        
        if (typeof raw !== "number" && typeof raw !== "string") continue;
        
        const value = typeof raw === "number" ? raw : (typeof raw === "string" ? raw.trim() : parseFloat(String(raw).replace(",", ".")));
        if (typeof value === "number" && !Number.isFinite(value)) continue;
        if (typeof value === "string" && !value) continue;

        const key = value.toString();
        allValues.add(key);
        
        const laneId = w.lane_id || "otros";
        if (laneId === "rswc") {
          rswcCounts[key] = (rswcCounts[key] || 0) + 1;
        } else if (laneId === "sys") {
          sysCounts[key] = (sysCounts[key] || 0) + 1;
        } else {
          otrosCounts[key] = (otrosCounts[key] || 0) + 1;
        }
      }

      if (allValues.size === 0) {
        showError(errorId, `No se han encontrado valores v√°lidos para ${field}.`);
        return;
      }

      const isNumeric = typeof Object.keys(Object.fromEntries(allValues.entries())).map(k => parseFloat(k))[0] === "number" && Number.isFinite(parseFloat(Array.from(allValues)[0]));
      const labels = isNumeric 
        ? Array.from(allValues).map(Number).filter((v) => Number.isFinite(v)).sort((a, b) => a - b).map(String)
        : Array.from(allValues).sort((a, b) => a.localeCompare(b));

      const ctx = document.getElementById(chartId);
      if (!ctx) {
        showError(errorId, "No se ha encontrado el lienzo del gr√°fico.");
        return;
      }

      const datasets = [];

      // Create datasets for each lane_id with their specific colors
      const rswcData = labels.map(label => rswcCounts[label] || 0);
      const sysData = labels.map(label => sysCounts[label] || 0);
      const otrosData = labels.map(label => otrosCounts[label] || 0);

      if (rswcData.some(v => v > 0)) {
        datasets.push({
          label: "RSWC",
          data: rswcData,
          backgroundColor: "rgba(218, 165, 32, 0.7)",
          borderColor: "rgba(218, 165, 32, 0.95)",
          borderWidth: 1.2,
          borderRadius: 6,
          hoverBackgroundColor: "rgba(184, 134, 11, 0.95)",
        });
      }

      if (sysData.some(v => v > 0)) {
        datasets.push({
          label: "Sol y Sombra",
          data: sysData,
          backgroundColor: "rgba(139, 92, 246, 0.7)",
          borderColor: "rgba(139, 92, 246, 0.95)",
          borderWidth: 1.2,
          borderRadius: 6,
          hoverBackgroundColor: "rgba(109, 40, 217, 0.95)",
        });
      }

      if (otrosData.some(v => v > 0)) {
        datasets.push({
          label: "Otros",
          data: otrosData,
          backgroundColor: "rgba(239, 68, 68, 0.7)",
          borderColor: "rgba(239, 68, 68, 0.95)",
          borderWidth: 1.2,
          borderRadius: 6,
          hoverBackgroundColor: "rgba(220, 38, 38, 0.95)",
        });
      }

      new Chart(ctx, {
        type: "bar",
        data: {
          labels,
          datasets: datasets,
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          interaction: {
            mode: 'index',
            intersect: false,
          },
          layout: { padding: { top: 10, right: 16, left: 4, bottom: 8 } },
          scales: {
            x: {
              stacked: true,
              title: { display: true, text: xLabel, color: "#e5e7eb", font: { size: 11, weight: "500" } },
              ticks: { color: "#9ca3af", font: { size: 10 } },
              grid: { display: false },
            },
            y: {
              stacked: true,
              beginAtZero: true,
              title: { display: true, text: yLabel, color: "#e5e7eb", font: { size: 11, weight: "500" } },
              ticks: { color: "#9ca3af", precision: 0, stepSize: 1, font: { size: 10 } },
              grid: { color: "rgba(55, 65, 81, 0.6)" },
            },
          },
          plugins: {
            legend: { 
              display: true,
              position: 'top',
              labels: { color: "#e5e7eb", font: { size: 10 } }
            },
            tooltip: {
              backgroundColor: "rgba(15, 23, 42, 0.96)",
              borderColor: "rgba(148, 163, 184, 0.7)",
              borderWidth: 1,
              padding: 10,
              titleColor: "#e5e7eb",
              bodyColor: "#e5e7eb",
              callbacks: {
                title(items) { return `${title}: ${items[0].label}`; },
                label(context) { 
                  const count = context.parsed.y;
                  const lane = context.dataset.label;
                  return `${lane}: ${count} ${count === 1 ? "reloj" : "relojes"}`; 
                },
                footer(items) {
                  const total = items.reduce((sum, item) => sum + item.parsed.y, 0);
                  return `Total: ${total} ${total === 1 ? "reloj" : "relojes"}`;
                }
              },
            },
          },
        },
      });
    }

    function buildUnitsProductionChart(watches) {
      if (!Array.isArray(watches) || watches.length === 0) {
        showError("units-production-error", "No hay datos disponibles.");
        return;
      }

      // Filter watches with units data and sort by lane_id and total units
      const watchesWithUnits = watches.filter(w => w && w.units && Array.isArray(w.units) && w.units.length > 0);
      
      if (watchesWithUnits.length === 0) {
        showError("units-production-error", "No se han encontrado datos de unidades.");
        return;
      }

      // Calculate total units for each watch
      watchesWithUnits.forEach(w => {
        w._totalUnits = w.units.reduce((sum, u) => sum + u, 0);
      });

      // Sort chronologically by year and month
      watchesWithUnits.sort((a, b) => {
        const yearA = a.year ?? 9999;
        const yearB = b.year ?? 9999;
        if (yearA !== yearB) return yearA - yearB;
        const monthA = a.month ?? 12;
        const monthB = b.month ?? 12;
        return monthA - monthB;
      });

      // Prepare data for stacked chart - just use title for x-axis labels
      const labels = watchesWithUnits.map(w => w.title || w.id);

      // Define color scheme by lane_id with two opacity levels for stacking
      const colorsByLane = {
        rswc: {
          light: "rgba(255, 215, 0, 0.5)",      // Bright gold, more transparent
          dark: "rgba(184, 134, 11, 0.95)",     // Dark gold, nearly opaque
          border: "rgba(218, 165, 32, 1)"
        },
        sys: {
          light: "rgba(167, 139, 250, 0.5)",    // Light purple, more transparent
          dark: "rgba(109, 40, 217, 0.95)",     // Dark purple, nearly opaque
          border: "rgba(139, 92, 246, 1)"
        },
        otros: {
          light: "rgba(252, 165, 165, 0.5)",    // Light red, more transparent
          dark: "rgba(220, 38, 38, 0.95)",      // Dark red, nearly opaque
          border: "rgba(239, 68, 68, 1)"
        }
      };

      // Helper function to create striped pattern with specified stripe color
      function createStripePattern(baseColor, stripeColor) {
        const canvas = document.createElement('canvas');
        canvas.width = 10;
        canvas.height = 10;
        const ctx = canvas.getContext('2d');
        
        // Background - base color
        ctx.fillStyle = baseColor;
        ctx.fillRect(0, 0, 10, 10);
        
        // Diagonal stripes at 45¬∞
        ctx.strokeStyle = stripeColor;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(0, 10);
        ctx.lineTo(10, 0);
        ctx.moveTo(-5, 15);
        ctx.lineTo(5, 5);
        ctx.moveTo(5, 15);
        ctx.lineTo(15, 5);
        ctx.stroke();
        
        return ctx.createPattern(canvas, 'repeat');
      }

      // Create datasets - one per watch-model combination
      const datasets = [];
      
      watchesWithUnits.forEach((watch, watchIdx) => {
        if (!watch.models || !watch.units || watch.models.length === 0) return;
        
        const laneId = watch.lane_id || "otros";
        const colors = colorsByLane[laneId] || colorsByLane.otros;
        
        // Create array of {modelName, units, index} and sort by units descending (most units first = bottom of stack)
        const modelData = watch.models.map((modelName, idx) => ({
          modelName: modelName,
          units: watch.units[idx] || 0,
          originalIndex: idx
        })).sort((a, b) => b.units - a.units); // Sort descending
        
        modelData.forEach((model, sortedIdx) => {
          let bgColor;
          
          // Pattern cycle: solid, white stripes, black stripes, repeat...
          const patternIndex = sortedIdx % 3;
          
          if (patternIndex === 0) {
            // Solid color
            bgColor = colors.dark;
          } else if (patternIndex === 1) {
            // White stripes
            bgColor = createStripePattern(colors.dark, 'rgba(255, 255, 255, 0.5)');
          } else {
            // Black stripes
            bgColor = createStripePattern(colors.dark, 'rgba(0, 0, 0, 0.5)');
          }
          
          // Create data array: only this watch's model has a value, others are 0
          const data = watchesWithUnits.map((w, idx) => {
            if (idx !== watchIdx) return 0;
            return model.units;
          });
          
          datasets.push({
            label: model.modelName,
            data: data,
            backgroundColor: bgColor,
            borderColor: colors.border,
            borderWidth: 1,
            borderRadius: 3,
            _watchId: watch.id,
            _watchTitle: watch.title
          });
        });
      });

      // Calculate statistics
      const rswcWatches = watchesWithUnits.filter(w => w.lane_id === "rswc");
      const sysWatches = watchesWithUnits.filter(w => w.lane_id === "sys");
      const otrosWatches = watchesWithUnits.filter(w => w.lane_id === "otros");

      // Get all individual models with their units (excluding "otros" category for top/exclusive lists)
      const allModels = [];
      const modelsForRanking = []; // Exclude "otros"
      watchesWithUnits.forEach(w => {
        if (w.models && w.units && w.models.length === w.units.length) {
          w.models.forEach((model, idx) => {
            // Format as "Title - Model" or just "Title" if model is empty
            const displayName = model && model.trim() ? `${w.title} - ${model}` : w.title;
            const modelData = {
              name: displayName,
              units: w.units[idx],
              watchId: w.id,
              title: w.title,
              model: model
            };
            allModels.push(modelData);
            // Only add to ranking if not "otros"
            if (w.lane_id !== "otros") {
              modelsForRanking.push(modelData);
            }
          });
        }
      });

      const ctx = document.getElementById("unitsProductionChart");
      if (!ctx) {
        showError("units-production-error", "No se ha encontrado el lienzo del gr√°fico.");
        return;
      }

      new Chart(ctx, {
        type: "bar",
        data: {
          labels,
          datasets: datasets,
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          interaction: {
            mode: 'index',
            intersect: false,
          },
          layout: { padding: { top: 10, right: 16, left: 4, bottom: 8 } },
          scales: {
            x: {
              stacked: true,
              title: { display: true, text: "Reloj", color: "#e5e7eb", font: { size: 11, weight: "500" } },
              ticks: { 
                color: "#9ca3af", 
                font: { size: 8 },
                maxRotation: 90,
                minRotation: 45,
                autoSkip: false,
              },
              grid: { display: false },
            },
            y: {
              stacked: true,
              beginAtZero: true,
              title: { display: true, text: "Unidades producidas", color: "#e5e7eb", font: { size: 11, weight: "500" } },
              ticks: { color: "#9ca3af", precision: 0, font: { size: 10 } },
              grid: { color: "rgba(55, 65, 81, 0.6)" },
            },
          },
          plugins: {
            legend: { 
              display: false  // Too many models, hide legend
            },
            tooltip: {
              backgroundColor: "rgba(15, 23, 42, 0.96)",
              borderColor: "rgba(148, 163, 184, 0.7)",
              borderWidth: 1,
              padding: 10,
              titleColor: "#e5e7eb",
              bodyColor: "#e5e7eb",
              callbacks: {
                title(items) { 
                  return items[0].label;  // Watch title
                },
                label(context) { 
                  const modelName = context.dataset.label;
                  const units = context.parsed.y;
                  if (units === 0) return null;  // Don't show 0 values
                  
                  const watchIndex = context.dataIndex;
                  const watch = watchesWithUnits[watchIndex];
                  const watchTitle = watch.title || watch.id;
                  
                  // Format as "Title - Model" or just "Title" if model is empty
                  const displayName = modelName && modelName.trim() 
                    ? `${watchTitle} - ${modelName}` 
                    : watchTitle;
                  
                  return `${displayName}: ${units} unidades`;
                },
                footer(items) {
                  const watchIndex = items[0].dataIndex;
                  const watch = watchesWithUnits[watchIndex];
                  const total = watch._totalUnits;
                  return `Total: ${total} unidades`;
                }
              },
            },
          },
        },
      });
    }

    async function init() {
      let data;
      try {
        const response = await fetch("zines_data.json", { cache: "no-store" });
        if (!response.ok) throw new Error(`Could not load data (status ${response.status})`);
        data = await response.json();
      } catch (error) {
        console.error(error);
        showError("strap-width-error", "No se han podido cargar los datos.");
        return;
      }

      if (typeof Chart === "undefined") {
        console.error("Chart.js no est√° disponible.");
        showError("strap-width-error", "Chart.js no se ha podido cargar.");
        return;
      }

      // Store data globally BEFORE setting up chart selector
      globalWatchData = data;

      // Build all charts
      try { buildDiameterStrapCorrelation(data); } catch (e) { console.error(e); }

      try { buildDiameterHeightCorrelation(data); } catch (e) { console.error(e); }

      try { buildDiameterLugCorrelation(data); } catch (e) { console.error(e); }

      try { buildYearlyAccumulatedChart(data); } catch (e) { console.error(e); }

      try { buildYearlyUnitsCumulative(data); } catch (e) { console.error(e); }

      try { buildYearlyVolumeCumulative(data); } catch (e) { console.error(e); }

      try { buildPriceLine(data); } catch (e) { console.error(e); }

      try { buildWaterResistChart(data); } catch (e) { console.error(e); }

      try {
        buildChart(data, {
          chartId: "movementTypeChart",
          errorId: "movement-type-error",
          field: "movement_type",
          title: "Tipo",
          xLabel: "Tipo de movimiento",
          yLabel: "N√∫mero de relojes",
          color: "rgba(129, 140, 248, 0.45)",
          borderColor: "rgba(79, 70, 229, 0.95)"
        });
      } catch (e) { console.error(e); }

      try {
        buildChart(data, {
          chartId: "movementCompanyChart",
          errorId: "movement-company-error",
          field: "movement_company",
          title: "Fabricante",
          xLabel: "Fabricante de calibre",
          yLabel: "N√∫mero de relojes",
          color: "rgba(251, 113, 133, 0.45)",
          borderColor: "rgba(244, 63, 94, 0.95)"
        });
      } catch (e) { console.error(e); }

      try { buildUnitsProductionChart(data); } catch (e) { console.error(e); }

      // Setup chart selector AFTER data is loaded so saved selection has data available
      setupChartSelector();
    }

    document.addEventListener("DOMContentLoaded", init);
  </script>
</body>
</html>
